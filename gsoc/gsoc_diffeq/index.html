<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title>SciML Numerical Differential Equations Projects – Google Summer of Code</title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://docs.sciml.ai/SciMLBenchmarksOutput/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=sciml_numerical_differential_equations_projects_google_summer_of_code ><a href="#sciml_numerical_differential_equations_projects_google_summer_of_code" class=header-anchor >SciML Numerical Differential Equations Projects – Google Summer of Code</a></h1> <h2 id=native_julia_ode_sde_dae_dde_and_spde_solvers ><a href="#native_julia_ode_sde_dae_dde_and_spde_solvers" class=header-anchor >Native Julia ODE, SDE, DAE, DDE, and &#40;S&#41;PDE Solvers</a></h2> <p>The DifferentialEquations.jl ecosystem has an extensive set of state-of-the-art methods for solving differential equations hosted by the <a href="https://sciml.ai/">SciML Scientific Machine Learning Software Organization</a>. By mixing native methods and wrapped methods under the same dispatch system, <a href="https://arxiv.org/abs/1807.06430">DifferentialEquations.jl serves both as a system to deploy and research the most modern efficient methodologies</a>. While most of the basic methods have been developed and optimized, many newer methods need high performance implementations and real-world tests of their efficiency claims. In this project students will be paired with current researchers in the discipline to get a handle on some of the latest techniques and build efficient implementations into the &#42;DiffEq libraries &#40;OrdinaryDiffEq.jl, StochasticDiffEq.jl, DelayDiffEq.jl&#41;. Possible families of methods to implement are:</p> <div class=tight-list ><ul> <li><p>Implicit-Explicit &#40;IMEX&#41; Runge-Kutta methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2860">#2860</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2065">#2065</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/728">#728</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/465">#465</a>&#41;</p> <li><p>New high-order explicit Runge-Kutta tableaux &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2694">#2694</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2621">#2621</a>&#41;</p> <li><p>Low-storage Runge-Kutta methods for hyperbolic PDEs and DG schemes &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2903">#2903</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2035">#2035</a>&#41;</p> <li><p>Positivity-preserving Rosenbrock methods for chemical kinetics &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2089">#2089</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1719">#1719</a>&#41;</p> <li><p>DIRK methods of Kennedy and Carpenter &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1448">#1448</a>&#41;</p> <li><p>Pseudo-symplectic and relaxation Runge-Kutta methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1987">#1987</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1029">#1029</a>&#41;</p> <li><p>Multi-rate methods and multi-rate extrapolation &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1195">#1195</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/884">#884</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/961">#961</a>&#41;</p> <li><p>Approximate matrix factorization &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/407">#407</a>&#41;</p> <li><p>Parallel DIRK and parallel Rosenbrock methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/789">#789</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/315">#315</a>&#41;</p> <li><p>Parallel-in-time ODE methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/962">#962</a>, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/34">#34</a>&#41;</p> <li><p>Boundary value problem &#40;BVP&#41; solvers like MIRK and collocation methods</p> <li><p>Methods for stiff stochastic differential equations</p> </ul></div> <p>See the full list of <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues?q&#61;is&#37;3Aissue&#43;state&#37;3Aopen&#43;label&#37;3Anew-algorithm">78 open new-algorithm issues</a> for all requested methods.</p> <p>Many of these methods are the basis of high-efficiency partial differential equation &#40;PDE&#41; solvers and are thus important to many communities like computational fluid dynamics, mathematical biology, and quantum mechanics.</p> <p>This project is good for both software engineers interested in the field of numerical analysis and those students who are interested in pursuing graduate research in the field.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis, numerical linear algebra, and the ability &#40;or eagerness to learn&#41; to write fast code.</p> <p><strong>Expected Results</strong>: Contributions of production-quality solver methods.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a>, <a href="https://github.com/kanav99">Kanav Gupta</a> and <a href="https://github.com/utkarsh530">Utkarsh</a>, <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Easy to Hard depending on the chosen subtasks.</p> <h2 id=global_error_estimation_and_control_for_differential_equations ><a href="#global_error_estimation_and_control_for_differential_equations" class=header-anchor >Global Error Estimation and Control for Differential Equations</a></h2> <p>Standard ODE solvers control only the <em>local</em> truncation error at each step, but users often care about the <em>global</em> &#40;accumulated&#41; error at the end of a simulation. <a href="https://github.com/SciML/GlobalDiffEq.jl">GlobalDiffEq.jl</a> aims to provide solvers that estimate and control global error for the DifferentialEquations.jl common interface. This project would develop practical, high-performance implementations of several complementary strategies from the numerical analysis literature:</p> <div class=tight-list ><ul> <li><p><strong>Adjoint-based global error estimation</strong>: Implement the method of <a href="https://epubs.siam.org/doi/abs/10.1137/S1064827503420969">Cao and Petzold &#40;2004&#41;</a>, which solves an adjoint &#40;backward-in-time&#41; problem to propagate local defect information into a global error estimate, combined with small-sample statistical condition estimation for efficiency.</p> <li><p><strong>Coupled time-stepping with built-in global error estimates</strong>: Implement the general linear method &#40;GLM&#41; framework of <a href="https://arxiv.org/abs/1503.05166">Constantinescu &#40;2018&#41;</a>, where the global error estimate is propagated forward alongside the numerical solution as a generalization of Zadunaisky&#39;s procedure, yielding self-starting explicit schemes akin to Runge-Kutta methods.</p> <li><p><strong>Specialized Runge-Kutta triples for global error control</strong>: Implement the methods of <a href="http://www.ehu.eus/ccwmuura/research/gee2003.pdf">Makazaga and Murua &#40;2003&#41;</a> and related schemes that extend the Dormand-Gilmore-Prince family of embedded RK pairs to cheaply produce global error estimates, with demonstrated efficiency gains &#40;e.g. 45&#37; step reduction on the Lorenz system&#41;.</p> <li><p><strong>Asymptotic expansion methods</strong>: Implement the approach of <a href="https://www.sciencedirect.com/science/article/pii/0898122186900325">Shampine &#40;1986&#41;</a>, which exploits the embedded pair infrastructure already present in standard solvers &#40;e.g. Tsit5, DP5&#41; to estimate global error via asymptotic error expansions at essentially no additional function evaluation cost.</p> <li><p><strong>Jacobian-based global error estimators</strong>: Implement methods from <a href="http://www.sci.utah.edu/publications/Ber1988b/Berzins_JSC1988.pdf">Berzins &#40;1988&#41;</a> that use Jacobian information to estimate global error propagation.</p> <li><p><strong>Global error controlled multistep methods</strong>: Implement multistep methods with built-in global error control, extending the classical Adams and BDF families.</p> </ul></div> <p>The resulting solvers would integrate directly with the SciML ecosystem, providing users with reliable global error bounds alongside their numerical solutions. This is particularly important for long-time integration problems in celestial mechanics, molecular dynamics, and climate modeling where local error control alone can be insufficient.</p> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis &#40;particularly ODE solver theory&#41;, familiarity with Runge-Kutta and multistep methods, and the ability &#40;or eagerness to learn&#41; to write fast Julia code. Some familiarity with adjoint methods is helpful but not required.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more global error estimation strategies in GlobalDiffEq.jl, with benchmarks demonstrating their accuracy and efficiency on standard test problems.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Medium to Hard depending on the chosen subtasks.</p> <h2 id=stabilized_explicit_methods_for_large-scale_parabolic_pdes ><a href="#stabilized_explicit_methods_for_large-scale_parabolic_pdes" class=header-anchor >Stabilized Explicit Methods for Large-Scale Parabolic PDEs</a></h2> <p>Semi-discretizations of parabolic PDEs &#40;e.g., heat equation, reaction-diffusion systems&#41; produce mildly stiff ODE systems whose eigenvalues lie along the negative real axis. Standard explicit methods require impractically small time steps for stability, while implicit methods require expensive linear solves. Stabilized explicit methods bridge this gap by using extended stability regions along the real axis, achieving explicit-method simplicity with near-implicit stability. OrdinaryDiffEq.jl already has ROCK2 and ROCK4, but many related methods remain unimplemented:</p> <div class=tight-list ><ul> <li><p><strong>Runge-Kutta-Chebyshev methods with monotonic stability</strong>: Implement the second-order RKC methods of <a href="https://doi.org/10.1016/j.cam.2025.117061">Faleichik and Moisa &#40;2026&#41;</a> with monotonic stability polynomials, improving robustness over classical RKC for problems with both diffusion and reaction terms. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2908">#2908</a>.</p> <li><p><strong>Two-step stabilized methods &#40;TSRKC2&#41;</strong>: Implement the two-step Runge-Kutta-Chebyshev methods of <a href="https://doi.org/10.1016/S0377042724001171">Moisa &#40;2024&#41;</a> which claim to outperform ROCK2 on large problems by exploiting information from the previous step. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2616">#2616</a>.</p> <li><p><strong>Runge-Kutta-Legendre and Runge-Kutta-Gegenbauer methods</strong>: Implement first- and second-order <a href="https://doi.org/10.1016/j.jcp.2013.08.021">RKL and RKG methods</a> as alternatives to RKC/ROCK with different stability region shapes suited to different problem classes. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2775">#2775</a>.</p> <li><p><strong>Dumka methods</strong>: Implement the <a href="http://dumkaland.org/publications/bit98medovikov.pdf">dumka3 and dumka4</a> stabilized methods of Medovikov, which use optimal stability polynomials. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1650">#1650</a>.</p> <li><p><strong>IMEX variants of stabilized methods</strong>: Implement IMEX Runge-Kutta-Chebyshev &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/135">#135</a>&#41; and partitioned IMEX ROCK &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/280">#280</a>&#41; methods for problems with both stiff diffusion and non-stiff reaction terms.</p> </ul></div> <p><strong>Recommended Skills</strong>: Background in numerical analysis, particularly stability theory of ODE methods. Familiarity with PDE discretizations is helpful.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more stabilized explicit methods with benchmarks against ROCK2/ROCK4.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Medium to Hard depending on the chosen subtasks.</p> <h2 id=exponential_integrators ><a href="#exponential_integrators" class=header-anchor >Exponential Integrators</a></h2> <p>Exponential integrators are a class of methods that exactly solve the linear part of a semilinear ODE <code>u&#39; &#61; Lu &#43; N&#40;u&#41;</code> using the matrix exponential &#40;or related phi-functions&#41;, and only discretize the nonlinear part <code>N&#40;u&#41;</code>. This makes them highly efficient for stiff problems arising from PDE semi-discretizations where the stiffness comes primarily from the linear operator. OrdinaryDiffEq.jl has some basic exponential methods, but many advanced variants remain open:</p> <div class=tight-list ><ul> <li><p><strong>Sixth-order exponential Runge-Kutta methods</strong>: Implement the high-order ExpRK methods of <a href="https://arxiv.org/abs/2311.08600">Luan and Alhsmy &#40;2023&#41;</a> for stiff parabolic PDEs, extending the current fourth-order methods. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2063">#2063</a>.</p> <li><p><strong>Robust exponential Runge-Kutta embedded pairs</strong>: Implement the adaptive embedded pairs of <a href="https://arxiv.org/abs/2303.12139">Zoto and Bowman &#40;2023&#41;</a> for automatic error control in exponential integrators. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1914">#1914</a>.</p> <li><p><strong>Adaptive step size controllers for exponential integrators</strong>: Implement the specialized controllers of <a href="https://doi.org/10.1016/j.camwa.2022.07.011">Deka and Einkemmer &#40;2022&#41;</a> that account for the specific error structure of exponential methods. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1755">#1755</a>.</p> <li><p><strong>Multi-rate exponential integrators</strong>: Implement methods from <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/720">#720</a> that combine exponential integration with multi-rate time stepping for problems with multiple time scales.</p> <li><p><strong>Adaptive Krylov exponential integrators &#40;EPIRK&#41;</strong>: Implement adaptive EPIRK methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/243">#243</a>&#41; that use Krylov subspace approximations to the matrix exponential, making exponential integrators practical for large-scale problems.</p> <li><p><strong>Symplectic exponential Runge-Kutta</strong>: Implement structure-preserving exponential methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/352">#352</a>&#41; for Hamiltonian systems with stiff linear parts.</p> </ul></div> <p>See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/394">#394</a> for the full list of exponential integrators to implement.</p> <p><strong>Recommended Skills</strong>: Background in numerical analysis, particularly matrix functions and Krylov methods. Familiarity with PDE semi-discretizations is helpful.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more exponential integrator families with benchmarks on stiff PDE test problems.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Medium to Hard depending on the chosen subtasks.</p> <h2 id=dae_solver_methods ><a href="#dae_solver_methods" class=header-anchor >DAE Solver Methods</a></h2> <p>Differential-algebraic equations &#40;DAEs&#41; arise naturally in acausal modeling &#40;ModelingToolkit.jl&#41;, circuit simulation, constrained mechanical systems, and chemical process engineering. While OrdinaryDiffEq.jl has basic DAE support via BDF and Radau methods, many specialized DAE solvers from the literature remain unimplemented:</p> <div class=tight-list ><ul> <li><p><strong>GAMD</strong>: Implement the <a href="https://archimede.dm.uniba.it/~testset/solvers/gamd.php">Generalized Adams Methods for DAEs</a>, a class of multistep methods specifically designed for DAE systems. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1542">#1542</a>.</p> <li><p><strong>BIMD</strong>: Implement the <a href="https://archimede.dm.uniba.it/~testset/solvers/bimd.php">Blended Implicit Methods for DAEs</a>, which combine implicit methods with blending techniques for improved stability on high-index DAEs. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1541">#1541</a>.</p> <li><p><strong>MEBDF</strong>: Implement the <a href="https://doi.org/10.1016/S0898-1221&#40;01&#41;00137-7">Modified Extended BDF methods</a>, which improve upon classical BDF methods by using additional off-step points for better stability. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/529">#529</a>.</p> <li><p><strong>Improved Radau methods for DAEs</strong>: Implement the <a href="https://arxiv.org/pdf/1302.1037.pdf">augmented low-rank Radau IIA</a> approach that reduces the cost of the linear algebra in implicit Runge-Kutta methods &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/622">#622</a>&#41;, and the improved DAE-specific Radau variant &#40;<a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/527">#527</a>&#41;.</p> <li><p><strong>Lobatto methods</strong>: Implement the classical <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/521">Lobatto IIIA, IIIB, and IIIC collocation schemes</a>, which are important for constrained Hamiltonian systems and index-2 DAEs.</p> <li><p><strong>BDF order and stability filtering</strong>: Implement <a href="https://arxiv.org/pdf/1810.06670.pdf">adaptive order and stability filtering</a> for BDF methods to improve robustness on difficult DAE systems. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/747">#747</a>.</p> <li><p><strong>GLIMDA and GENDA</strong>: Implement the <a href="https://edoc.hu-berlin.de/handle/18452/16193">general linear method for DAEs</a> &#40;GLIMDA, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/528">#528</a>&#41; and the <a href="https://www3.math.tu-berlin.de/multiphysics/Software/GENDA/">general ENsemble DAE solver</a> &#40;GENDA, <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/526">#526</a>&#41;.</p> </ul></div> <p><strong>Recommended Skills</strong>: Background in numerical analysis, particularly differential-algebraic equations and implicit methods. Familiarity with linear algebra factorizations is helpful.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more DAE solver methods, tested against the <a href="https://archimede.dm.uniba.it/~testset/">DAE test set</a>.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Hard.</p> <h2 id=lie_group_and_geometric_integration_methods ><a href="#lie_group_and_geometric_integration_methods" class=header-anchor >Lie Group and Geometric Integration Methods</a></h2> <p>Many differential equations arising from physics &#40;rigid body dynamics, quantum mechanics, robotics&#41; have solutions that evolve on Lie groups or manifolds rather than in Euclidean space. Lie group integrators preserve this geometric structure, avoiding drift off the manifold that plagues standard methods. OrdinaryDiffEq.jl has some basic Lie group integrators, but many methods remain unimplemented:</p> <div class=tight-list ><ul> <li><p><strong>Commutator-free Lie group methods</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1072">commutator-free methods</a> that avoid evaluating nested Lie brackets, making them practical for high-dimensional problems.</p> <li><p><strong>Commutator-free Magnus methods</strong>: Implement the fourth- and sixth-order <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1069">commutator-free Magnus integrators</a> for time-dependent linear ODEs on Lie groups.</p> <li><p><strong>Fer and Cayley expansion methods</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1068">Fer expansions and Cayley-transform-based integrators</a> as alternatives to Magnus methods for time-dependent linear ODEs.</p> <li><p><strong>Adaptive Magnus schemes</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1065">embedded Magnus pairs</a> for automatic step size control in Magnus integrators.</p> <li><p><strong>Additional RKMK methods</strong>: Implement higher-order <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1067">Runge-Kutta-Munthe-Kaas methods</a> for general ODEs on Lie groups.</p> <li><p><strong>Operator splitting methods</strong>: Implement higher-order <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/1063">Strang and symmetrized splitting methods</a> with composition techniques for problems decomposable into exactly solvable parts.</p> </ul></div> <p><strong>Recommended Skills</strong>: Background in differential geometry or Lie group theory is helpful but not required. Familiarity with numerical ODE methods and the ability to write Julia code.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more Lie group integration methods with tests on rigid body and quantum mechanics problems.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Medium to Hard depending on the chosen subtasks.</p> <h2 id=second-order_ode_and_runge-kutta-nystrom_methods ><a href="#second-order_ode_and_runge-kutta-nystrom_methods" class=header-anchor >Second-Order ODE and Runge-Kutta-Nystrom Methods</a></h2> <p>Many physical systems &#40;celestial mechanics, molecular dynamics, structural vibrations&#41; are naturally described by second-order ODEs <code>q&#39;&#39; &#61; f&#40;q, q&#39;, t&#41;</code>. While these can always be converted to first-order systems, specialized Runge-Kutta-Nystrom &#40;RKN&#41; methods that exploit the second-order structure are significantly more efficient. OrdinaryDiffEq.jl has some basic RKN methods, but many advanced variants remain open:</p> <div class=tight-list ><ul> <li><p><strong>Explicit RKN methods for linear inhomogeneous IVPs</strong>: Implement the methods of <a href="https://doi.org/10.1016/j.cam.2023.115533">Montijano, Randez, and Calvo &#40;2024&#41;</a> that exploit linearity for improved efficiency. See <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/2043">#2043</a>.</p> <li><p><strong>High-order Numerov-type methods</strong>: Implement the <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/866">eighth- and ninth-order explicit Numerov-type methods</a> for second-order problems without first derivatives, widely used in quantum chemistry and wave propagation.</p> <li><p><strong>SDIRKN methods</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/865">singly-diagonally-implicit RKN methods</a> for stiff second-order problems.</p> <li><p><strong>Implicit RKN methods</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/112">implicit Runge-Kutta-Nystrom methods</a> for stiff oscillatory systems.</p> <li><p><strong>More explicit RKN methods</strong>: Implement the extensive collection of methods from <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/677">Dormand, Prince, Filippi, Sharp, and others</a> with various order/stage tradeoffs and dense output capabilities.</p> <li><p><strong>Stoermer extrapolation</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/332">Stoermer&#39;s rule with extrapolation</a> &#40;the ODEX2 algorithm from Hairer&#41; for high-accuracy second-order problems.</p> <li><p><strong>Multistep second-order methods</strong>: Implement <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/331">Gauss-Jackson, Stormer-Cowell, and Berry-Healy methods</a> used in satellite orbit propagation.</p> <li><p><strong>Structure-preserving algorithms for oscillatory ODEs</strong>: Implement methods from the <a href="https://github.com/SciML/OrdinaryDiffEq.jl/issues/351">Springer monograph</a> on structure-preserving integrators for oscillatory differential equations.</p> </ul></div> <p><strong>Recommended Skills</strong>: Background in numerical analysis, particularly Nystrom methods and symplectic integration. Familiarity with celestial mechanics or molecular dynamics applications is helpful.</p> <p><strong>Expected Results</strong>: Production-quality implementations of two or more second-order ODE methods with benchmarks on orbital mechanics or molecular dynamics problems.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Easy to Hard depending on the chosen subtasks.</p> <h2 id=performance_enhancements_for_differential_equation_solvers ><a href="#performance_enhancements_for_differential_equation_solvers" class=header-anchor >Performance enhancements for differential equation solvers</a></h2> <p>Wouldn&#39;t it be cool to have had a part in the development of widely used efficient differential equation solvers? DifferentialEquations.jl has a wide range of existing methods and <a href="https://github.com/SciML/DiffEqBenchmarks.jl">an extensive benchmark suite</a> which is used for tuning the methods for performance. Many of its methods are already the fastest in their class, but there is still a lot of performance enhancement work that can be done. In this project you can learn the details about a wide range of methods and dig into the optimization of the algorithm&#39;s strategy and the implementation in order to improve benchmarks. Projects that could potentially improve the performance of the full differential equations ecosystem include:</p> <div class=tight-list ><ul> <li><p>Alternative adaptive stepsize techniques and step optimization</p> <li><p>Pointer swapping tricks</p> <li><p>Quasi-Newton globalization and optimization</p> <li><p>Cache size reductions</p> <li><p>Enhanced within-method multithreading, distributed parallelism, and GPU usage</p> <li><p>Improved automated method choosing</p> <li><p>Adaptive preconditioning on large-scale &#40;PDE&#41; discretizations</p> </ul></div> <p><strong>Recommended Skills</strong>: Background knowledge in numerical analysis, numerical linear algebra, and the ability &#40;or eagerness to learn&#41; to write fast code.</p> <p><strong>Expected Results</strong>: Improved benchmarks to share with the community.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/oscardssmith">Oscar Smith</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Easy to Hard depending on the chosen subtasks.</p> <h2 id=discretizations_of_partial_differential_equations ><a href="#discretizations_of_partial_differential_equations" class=header-anchor >Discretizations of partial differential equations</a></h2> <p>There are two ways to approach libraries for partial differential equations &#40;PDEs&#41;: one can build &quot;toolkits&quot; which enable users to discretize any PDE but require knowledge of numerical PDE methods, or one can build &quot;full-stop&quot; PDE solvers for specific PDEs. There are many different ways solving PDEs could be approached, and here are some ideas for potential projects:</p> <div class=tight-list ><ol> <li><p>Automated PDE discretization tooling. We want users to describe a PDE in its mathematical form and automate the rest of the solution process. See <a href="https://github.com/SciML/DifferentialEquations.jl/issues/469">this issue for details</a>.</p> <li><p>Enhancement of existing tools for discretizing PDEs. The finite differencing &#40;FDM&#41; library <a href="https://github.com/SciML/MethodOfLines.jl">MethodOfLines.jl</a> could be enhanced to allow non-uniform grids or composition of operators. The finite element method &#40;FEM&#41; library <a href="https://github.com/SciML/FEniCS.jl">FEniCS.jl</a> could wrap more of the FEniCS library.</p> <li><p>Full stop solvers of common fluid dynamical equations, such as diffusion-advection-convection equations, or of hyperbolic PDEs such as the Hamilton-Jacobi-Bellman equations would be useful to many users.</p> <li><p>Using stochastic differential equation &#40;SDE&#41; solvers to efficiently &#40;and highly parallel&#41; approximate certain PDEs.</p> <li><p>Development of ODE solvers for more efficiently solving specific types of PDE discretizations. See the &quot;Native Julia solvers for ordinary differential equations&quot; project.</p> </ol></div> <p><strong>Recommended Skills</strong>: Background knowledge in numerical methods for solving differential equations. Some basic knowledge of PDEs, but mostly a willingness to learn and a strong understanding of calculus and linear algebra.</p> <p><strong>Expected Results</strong>: A production-quality PDE solver package for some common PDEs.</p> <p><strong>Mentors</strong>: <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a> and <a href="https://github.com/xtalax">Alex Jones</a></p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Medium to Hard depending on the chosen subtasks.</p> <h2 id=jump_process_simulation_algorithms ><a href="#jump_process_simulation_algorithms" class=header-anchor >Jump Process Simulation Algorithms</a></h2> <p>Jump processes are a widely used approach for modeling biological, chemical and epidemiological systems that can account for both stochastic interactions, and spatial transport, of proteins/particles/agents. <a href="https://github.com/SciML/JumpProcesses.jl/">JumpProcesses.jl</a> provides a library of optimized solvers for exactly simulating jump processes, including recently added solvers that allow for the simulation of spatially-distributed jump processes &#40;where particles/agents move on graphs or general meshes&#41;. A variety of possible projects to extend and enhance the current tooling include</p> <div class=tight-list ><ul> <li><p>Adding additional stochastic simulation algorithms such as partial propensity methods &#40;either explicitly or via wrapping the C&#43;&#43; <a href="https://github.com/breezerider/pSSAlib">pSSALib</a>&#41;, or more recent methods listed in JumpProcesses issues.</p> <li><p>Exploring cache-optimized table and queue data structures to improve performance of current solvers.</p> <li><p>Extending the current graph and spatial algorithms to support interactions between particles/agents at different spatial locations, and developing tooling to automatically calculate transition rates via PDE discretization techniques.</p> <li><p>Extending StochasticDiffEq.jl with τ-leap algorithms to enable the approximate, but more computationally efficient, simulation of jump processes.</p> <li><p>Extending JumpProcesses and StochasticDiffEq with hybrid simulation capabilities, allowing models that mix ODEs, SDE and jump processes and can dynamically partition model components between each mathematical representation as needed to maintain physical accuracy.</p> </ul></div> <p><strong>Recommended Skills</strong>: Stochastic processes, numerical ODEs, an understanding of how the Gillespie method or basic jump process simulation algorithms work, and experience using JumpProcesses.jl to simulate jump processes.</p> <p><strong>Expected Results</strong>: Completing one or more of the preceding improvements to the jump process simulation tooling.</p> <p><strong>Mentors</strong>: <a href="https://github.com/isaacsas">Samuel Isaacson</a> and <a href="https://github.com/ChrisRackauckas">Chris Rackauckas</a>.</p> <p><strong>Expected Project Size</strong>: 350 hour.</p> <p><strong>Difficulty</strong>: Hard, generally requires significant mathematical and/or theoretical chemistry background beyond beginning undergraduate classes, including background in stochastic processes and their numerical simulation. Only recommended for advanced undergraduates and/or graduate students. Not a project that AIs can handle without substantial, informed supervision and planning. </p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>