<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title>SciML Developer Chat Episode 1: Trimming, Base Splits, and Symbolics Precompilation</title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://benchmarks.sciml.ai/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=sciml_developer_chat_episode_1_trimming_base_splits_and_symbolics_precompilation ><a href="#sciml_developer_chat_episode_1_trimming_base_splits_and_symbolics_precompilation" class=header-anchor >SciML Developer Chat Episode 1: Trimming, Base Splits, and Symbolics Precompilation</a></h1> <p>Welcome to the inaugural SciML Developer Chat&#33; This is a new format we&#39;re trying out to share what&#39;s happening behind the scenes in SciML development. Rather than waiting for formal blog posts or annual JuliaCon talks, we&#39;re pulling developers together for casual discussions about ongoing work.</p> <p>You can watch the full video here:</p> <iframe width=560  height=315  src="https://www.youtube.com/embed/0yQ4aZ-ABhY?si=5LIR8gayIkvxyM6Z" title="YouTube video player" frameborder=0  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy=strict-origin-when-cross-origin  allowfullscreen></iframe> <p>&#40;This is an AI-assisted summary of the discussion&#41;</p> <p>In this first episode, Chris Rackauckas, Oscar Smith, and Ayush Sabharwal discuss four major development efforts currently underway in the SciML ecosystem. Let&#39;s dive into each topic.</p> <h2 id=trimming_support_throughout_sciml ><a href="#trimming_support_throughout_sciml" class=header-anchor >Trimming Support Throughout SciML</a></h2> <p>One of the most exciting recent developments has been getting SciML to work with Julia&#39;s static compilation and trimming capabilities. This effort kicked off at the JuliaCon hackathon when Romeo showed up and said, &quot;I want to get JuliaC and trimming working on SciML.&quot; What started as a prototype that required specific development branches and exact algorithm choices has evolved into robust, well-tested support.</p> <h3 id=what_is_trimming ><a href="#what_is_trimming" class=header-anchor >What is Trimming?</a></h3> <p>Trimming refers to Julia&#39;s ability to create statically compiled binaries that only include the code paths actually used by your program. This is crucial for deployment scenarios where you want minimal binary sizes and don&#39;t want to ship the entire Julia runtime.</p> <h3 id=the_technical_challenges ><a href="#the_technical_challenges" class=header-anchor >The Technical Challenges</a></h3> <p>Making SciML trimmable required changes throughout the stack:</p> <p><strong>Base Julia Changes</strong>: Gabriel and Cody worked on making various parts of Base compatible with trimming, particularly around error paths. In regular Julia, dynamic behavior on error paths is acceptable since errors are rare. For trimming, these needed to be either made static or configured to abort on error.</p> <p><strong>LinearSolve.jl</strong>: This was one of the biggest challenges. The library now uses <code>@static</code> annotations extensively to satisfy trimming constraints. The key rule: you must be able to determine statically which algorithm you&#39;re using. Dynamic algorithm selection &#40;like checking <code>CUDA.functional&#40;&#41;</code> at runtime&#41; breaks trimming because it might try to compile code for systems you don&#39;t have.</p> <p>The solution involved creating functions that are always false by default, then overwriting them via extensions when CUDA is actually loaded. This way, if you&#39;re not building with CUDA, the code remains static and trimmable.</p> <p><strong>CPUSummary.jl</strong>: This required a major redesign. Previously, it would <code>eval</code> in CPU properties at init time &#40;cache sizes, core counts, etc.&#41;. Now it uses Preferences.jl, making everything static at compile time. The trade-off: binaries are no longer relocatable to different CPU architectures. Your binary will be optimized for the CPU you built it on, not the one you&#39;re running it on. This is acceptable for most deployment scenarios but something to be aware of.</p> <h3 id=current_status ><a href="#current_status" class=header-anchor >Current Status</a></h3> <p>As of now:</p> <ul> <li><p>Explicit solvers &#40;Tsit5, Vern7&#41; work out of the box</p> <li><p>Semi-implicit solvers &#40;Rosenbrocks&#41; work with the linearsolve changes</p> <li><p>NonlinearSolve.jl has comprehensive trim tests</p> <li><p>One remaining piece: getting the full robust default algorithm stack to trim</p> </ul> <p>Oscar demonstrated that Rosenbrock solvers now trim successfully, though initialization algorithms need attention. The initialization does use nonlinear solve, so we need the full robust nonlinear solver stack to be trimmable.</p> <h3 id=testing_strategy ><a href="#testing_strategy" class=header-anchor >Testing Strategy</a></h3> <p>Romeo put together an impressive test infrastructure in NonlinearSolve.jl that actually runs <code>juliac</code>, builds a binary, and tests it in a separate process. This is the gold standard, though it&#39;s time-intensive to set up in every repo. We&#39;re exploring using JET for static analysis as an alternative, though it has had some false positive issues that were recently resolved in Julia 1.12.</p> <p>The plan is to create a downstream integration test where SciMLBase calls NonlinearSolve.jl&#39;s trim test, then write a similar test for ODE solvers.</p> <h2 id=base_splitting_refactors ><a href="#base_splitting_refactors" class=header-anchor >Base Splitting Refactors</a></h2> <p>If you&#39;ve noticed some version instability in SciML packages recently, this is why. We&#39;ve been restructuring the entire dependency graph to create a cleaner, more modular architecture.</p> <h3 id=the_old_architecture_problem ><a href="#the_old_architecture_problem" class=header-anchor >The Old Architecture Problem</a></h3> <p>In the early days of DifferentialEquations.jl &#40;around 2016&#41;, we made some architectural choices that made sense at the time but became problematic as the ecosystem grew:</p> <ol> <li><p><strong>SteadyStateDiffEq as a special case</strong>: Steady state problems are essentially nonlinear problems &#40;ODEs run to infinity&#41;, so <code>AbstractNonlinearProblem</code> inherited from <code>AbstractDiffEqProblem</code>. This meant NonlinearSolve.jl depended on DiffEqBase.jl.</p> <li><p><strong>Circular dependency issues</strong>: The nonlinear solvers used in ODE solver callbacks couldn&#39;t come from NonlinearSolve.jl because that would create a circular dependency. So we had duplicate nonlinear solver implementations.</p> <li><p><strong>Shared code duplication</strong>: All the keyword argument checking, type promotion, and compatibility checking was duplicated across problem types.</p> </ol> <h3 id=the_new_architecture ><a href="#the_new_architecture" class=header-anchor >The New Architecture</a></h3> <p>We&#39;ve restructured to create a cleaner hierarchy:</p> <pre><code class="julia hljs">SciMLBase.jl
                         |
        +----------------+----------------+
        |                |                |
   DiffEqBase      NonlinearSolveBase  OptimizationBase
        |                |                |
   OrdinaryDiffEq   NonlinearSolve   Optimization.jl</code></pre> <p><strong>SciMLBase.jl</strong> sits at the bottom with functionality shared by ALL SciML solvers:</p> <ul> <li><p>Element type checking and promotion</p> <li><p>Distribution handling</p> <li><p>U0 compatibility validation</p> <li><p>Parameter promotion</p> </ul> <p><strong>Specialized base packages</strong> &#40;DiffEqBase, NonlinearSolveBase, OptimizationBase&#41; contain code shared within each solver family.</p> <p><strong>Solver libraries</strong> depend only on their respective base packages.</p> <h3 id=benefits ><a href="#benefits" class=header-anchor >Benefits</a></h3> <ol> <li><p><strong>No more circular dependencies</strong>: NonlinearSolve.jl can be used independently of differential equation solvers</p> <li><p><strong>Correct error messages</strong>: Nonlinear solvers no longer throw error messages about ODE function syntax</p> <li><p><strong>Reduced compilation times</strong>: You don&#39;t pull in Fortran dependencies from Optimization.jl when you just want to use OptimizationOptimisers.jl</p> <li><p><strong>Cleaner symbolic indexing</strong>: No more weird cases where nonlinear problems inherit time-dependence from being subtypes of DE problems</p> </ol> <h3 id=what_users_see ><a href="#what_users_see" class=header-anchor >What Users See</a></h3> <p>There were some versions that didn&#39;t precompile during this transition - that&#39;s what all the version bumps were about. We had the same function defined in two base packages temporarily during the migration.</p> <p>The good news: this is now complete except for possibly merging DiffEqBase into OrdinaryDiffEqCore. Since Sundials.jl v5 now uses the same initialization interface as OrdinaryDiffEq, there&#39;s less need for a separate base package. However, this change might be more annoying than it&#39;s worth, so we&#39;re still discussing it.</p> <h3 id=future_work ><a href="#future_work" class=header-anchor >Future Work</a></h3> <p>We may create even more specialized base packages:</p> <ul> <li><p><strong>LinearSolveBase.jl</strong>: A minimal version that builds without MKL, even though we default to using MKL</p> <li><p><strong>SciMLSensitivityBase.jl</strong>: A minimal version without Enzyme, even though we default to using Enzyme</p> </ul> <p>This would enable building binaries without these heavy dependencies when needed, while still defaulting to them for normal use.</p> <h2 id=symbolicutils_v40_rewrite ><a href="#symbolicutils_v40_rewrite" class=header-anchor >SymbolicUtils v4.0 Rewrite</a></h2> <p>This is perhaps the most ambitious change discussed in the episode. Ayush has been leading a complete rewrite of SymbolicUtils.jl, the foundation of ModelingToolkit.jl&#39;s symbolic manipulation capabilities.</p> <h3 id=the_motivation ><a href="#the_motivation" class=header-anchor >The Motivation</a></h3> <p>If you&#39;ve ever loaded ModelingToolkit and tried to simplify an ODE system, you&#39;ve noticed it takes a while on the first call, even though we precompile what we can. The root cause: nothing in symbolic manipulation was type stable. Everything eventually gave up and fell back to <code>Any</code>.</p> <h3 id=the_technical_challenge ><a href="#the_technical_challenge" class=header-anchor >The Technical Challenge</a></h3> <p>Symbolic computing requires different internal representations for optimal performance:</p> <ul> <li><p><strong>Polynomials</strong>: Should use &quot;add muls&quot; - dictionaries where keys are terms and values are coefficients. This makes associative/commutative rules trivial to apply &#40;x &#43; y &#43; z &#61;&#61; y &#43; x &#43; z is just dictionary equality&#41;.</p> <li><p><strong>General expressions</strong>: Tree representation with operation and arguments.</p> <li><p><strong>Arrays</strong>: Need special handling with Einstein summation notation.</p> </ul> <p>But if your tree nodes can be any of these types, you end up with <code>Array&#123;Any&#125;</code> for the arguments, destroying type stability.</p> <h3 id=the_solution_sum_types ><a href="#the_solution_sum_types" class=header-anchor >The Solution: Sum Types</a></h3> <p>SymbolicUtils v4.0 introduces a Moshi sum type &#40;similar to Rust enums or OCaml variants&#41;.</p> <p>This is one type with a union of different internal representations. Arrays of <code>BasicSymbolic</code> are type stable, even if they contain a mix of terms, polynomials, and constants. Runtime checks determine which variant you have, but the type itself is stable.</p> <h3 id=major_breaking_changes ><a href="#major_breaking_changes" class=header-anchor >Major Breaking Changes</a></h3> <p><strong>1. No Type Parameters for Value Types</strong></p> <p>Previously: <code>BasicSymbolic&#123;Real&#125;</code>, <code>Symbolic&#123;Vector&#123;Real&#125;&#125;</code></p> <p>Now: Just <code>BasicSymbolic</code>. The value type is stored as metadata but not in the type parameter.</p> <p>Why: Functions can return scalars or arrays depending on their arguments. You can&#39;t store argument types in a type-stable way if the return type depends on runtime values.</p> <p><strong>2. Symbolic Constants</strong></p> <p>Previously: <code>x - x</code> would return <code>0</code> &#40;an integer&#41;</p> <p>Now: <code>x - x</code> returns a blue <code>const&#40;0&#41;</code> &#40;a symbolic constant&#41;</p> <p>This ensures that any operation on symbolics returns a symbolic. This is the basis of type stability - you can statically infer that adding two symbolics gives a symbolic, not potentially a number or array.</p> <p>If you actually want a number, you must explicitly request it &#40;e.g., with <code>val&#61;true</code> in substitute&#41;.</p> <h3 id=array_support_improvements ><a href="#array_support_improvements" class=header-anchor >Array Support Improvements</a></h3> <p>The rewrite includes first-class support for arrays:</p> <ul> <li><p><strong>Undefined sizes</strong>: Symbolic arrays can have unknown dimensions. Code generation will loop over <code>axes&#40;x, 1&#41;</code> and <code>axes&#40;x, 2&#41;</code>.</p> <li><p><strong>O&#40;1&#41; discretization</strong>: PDE discretization code can be generated that works for any discretization size. Change your grid resolution, use the same compiled code.</p> <li><p><strong>Array operations</strong>: Full primitive array algebra with potential for future loop fusion optimizations.</p> </ul> <p>This is particularly important for MethodOfLines.jl, which should see dramatic compile time improvements once fully integrated.</p> <h3 id=performance_implications ><a href="#performance_implications" class=header-anchor >Performance Implications</a></h3> <p>The type stability enables precompilation of symbolic workflows. Simplifying an ODE system should become nearly instantaneous instead of taking 30&#43; seconds on the first call.</p> <p>Ayush has optimized specific algorithms that are commonly used. Making 100&#37; of Symbolics.jl type stable will take several more months, but the critical paths are done.</p> <h3 id=migration_path ><a href="#migration_path" class=header-anchor >Migration Path</a></h3> <p>SymbolicUtils v4.0 is released. Symbolics.jl is almost updated. ModelingToolkit.jl integration is ongoing. Some scalarization analysis still needs work to avoid breaking up array operations unnecessarily.</p> <p>Daria is working on integrating Bumper.jl and Reactant.jl so generated code with array operations will be non-allocating and fast by default.</p> <h2 id=differentialequationsjl_v8_breaking_changes ><a href="#differentialequationsjl_v8_breaking_changes" class=header-anchor >DifferentialEquations.jl v8 Breaking Changes</a></h2> <p>The final topic covered the upcoming breaking changes to DifferentialEquations.jl and OrdinaryDiffEq.jl.</p> <h3 id=the_core_problem ><a href="#the_core_problem" class=header-anchor >The Core Problem</a></h3> <p>DifferentialEquations.jl was designed as a batteries-included package that depends on everything. This made sense when the ecosystem was small, but now:</p> <ul> <li><p>Almost nobody solves stochastic equations, boundary value problems, AND DAEs in the same session</p> <li><p>People want to use sub-libraries independently</p> <li><p>The default algorithm having dependencies on everything means pulling in unnecessary code</p> </ul> <h3 id=the_solution_restructuring ><a href="#the_solution_restructuring" class=header-anchor >The Solution: Restructuring</a></h3> <p><strong>DifferentialEquations.jl v8</strong> will become focused specifically on ODEs. It will:</p> <ul> <li><p>Contain only the 6-10 solvers that 99.9&#37; of people use</p> <li><p>Load quickly</p> <li><p>Not depend on every solver package</p> </ul> <p>For other problem types, use the specific packages:</p> <ul> <li><p><code>StochasticDiffEq.jl</code> for SDEs</p> <li><p><code>DelayDiffEq.jl</code> for DDEs </p> <li><p><code>BoundaryValueDiffEq.jl</code> for BVPs</p> <li><p><code>SteadyStateDiffEq.jl</code> for steady states</p> </ul> <p>Documentation at diffq.sciml.ai has already been updated to guide users to the appropriate package.</p> <p><strong>OrdinaryDiffEq.jl v7</strong> will be split so additional solvers are in separate packages:</p> <ul> <li><p>Core solvers in OrdinaryDiffEq.jl</p> <li><p>Specialized solvers &#40;Feagin, extrapolation methods, etc.&#41; in extension packages</p> </ul> <h3 id=other_breaking_changes ><a href="#other_breaking_changes" class=header-anchor >Other Breaking Changes</a></h3> <p><strong>1. Preconditioner Interface</strong></p> <p>Preconditioners now go as arguments to your <code>linsolve</code> parameter, not as separate solver arguments. This makes it easier to:</p> <ul> <li><p>Switch out solvers</p> <li><p>Save and reuse built preconditioners </p> <li><p>Use simple preconditioners like AMG without custom code</p> </ul> <p><strong>2. Check Initialization by Default</strong></p> <p>For DAE problems, the solver will now check that your initial conditions are consistent by default &#40;like Sundials.jl v5 already does&#41;. You must explicitly tell it if you want it to modify your initial conditions.</p> <p>This prevents confusing interactions with callbacks where inconsistent initial conditions silently changed.</p> <p><strong>3. Trimming-Compatible Default Controllers</strong></p> <p>Various bits of the controller interface that were runtime dynamic will become type-level static to support trimming.</p> <h3 id=open_questions ><a href="#open_questions" class=header-anchor >Open Questions</a></h3> <p><strong>Should we default to Enzyme instead of ForwardDiff?</strong></p> <p>Decision: <strong>No</strong>. The experience with Julia 1.11 showed that Enzyme support can lag for months on new Julia releases. We can&#39;t have OrdinaryDiffEq not working on new Julia versions for 6 months. ForwardDiff always works day one.</p> <p>Users can easily switch to Enzyme when needed, but the default needs to be maximally robust.</p> <p><strong>Can we delete OrdinaryDiffEq&#39;s internal nonlinear solvers?</strong></p> <p>This is the big question mark. Oscar is working to make NonlinearSolve.jl fast enough for the specific use case inside ODE solvers. If successful, we can:</p> <ul> <li><p>Delete a lot of OrdinaryDiffEq&#39;s code</p> <li><p>Get better nonlinear convergence &#40;trust region methods, line searches&#41;</p> <li><p>Allow larger time steps</p> <li><p>Have one less internal implementation to maintain</p> </ul> <p>The challenge: ODE solvers need very specific hooks and performance characteristics. We&#39;re optimizing NonlinearSolve.jl to meet these needs over the next 1-2 months.</p> <p>This might not technically be a breaking change &#40;how nonlinear solving is done internally isn&#39;t part of the API&#41;, but it&#39;s sweeping enough that bundling it with v7 makes sense.</p> <p><strong>Will we switch to DifferentiationInterface.jl?</strong></p> <p>Possibly. Oscar is considering changes to how you specify derivatives &#40;Jacobians, W operators, VJPs, JVPs&#41;. The current interface isn&#39;t quite right, and DifferentiationInterface.jl provides a nice audited standard.</p> <p>This could be the actual breaking part of the nonlinear solve integration, more than the solver change itself.</p> <h3 id=dae_solvers ><a href="#dae_solvers" class=header-anchor >DAE Solvers</a></h3> <p>An open GSOC project: finish DFBDF to be better than IDA from Sundials. Current status:</p> <ul> <li><p>DFBDF is often faster than IDA</p> <li><p>Missing: collocation polynomial interpolation &#40;currently uses Hermite polynomials, less stable&#41;</p> <li><p>Has callback support &#40;added earlier this year&#41;</p> </ul> <p>However, for most users, the recommendation remains: use mass matrix ODE formulations instead of DAE problems. Every benchmark shows they&#39;re faster and more robust. ModelingToolkit.jl defaults to this approach.</p> <h3 id=merging_repositories ><a href="#merging_repositories" class=header-anchor >Merging Repositories</a></h3> <p>StochasticDiffEq.jl and DelayDiffEq.jl will likely be merged into OrdinaryDiffEq.jl. They reuse so much of the same code &#40;everything except their specific time steppers&#41; that keeping them separate has become a maintenance burden.</p> <p>They use internal OrdinaryDiffEq code that has &quot;no interface and is horrible,&quot; so merging them enables cleaning this up.</p> <p>BoundaryValueDiffEq.jl will likely stay separate - it&#39;s different enough to warrant its own package.</p> <h2 id=timeline ><a href="#timeline" class=header-anchor >Timeline</a></h2> <p>These changes are happening now:</p> <ul> <li><p><strong>SymbolicUtils v4.0</strong>: Released</p> <li><p><strong>Symbolics.jl update</strong>: Nearly complete </p> <li><p><strong>NonlinearSolveBase/OptimizationBase</strong>: Complete</p> <li><p><strong>Trimming support</strong>: Most infrastructure done, testing ongoing</p> <li><p><strong>OrdinaryDiffEq v7 / DifferentialEquations.jl v8</strong>: Target next 1-2 months</p> </ul> <p>This is a lot of breaking changes at once, but consolidating them means:</p> <ul> <li><p>One migration period instead of multiple</p> <li><p>Aligned ecosystem upgrades</p> <li><p>Taking advantage of the break to fix multiple pain points at once</p> </ul> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>These changes represent months of work from many contributors:</p> <ul> <li><p><strong>Romeo</strong>: Trimming prototype and test infrastructure</p> <li><p><strong>Gabriel and Cody</strong>: Base Julia trimming support </p> <li><p><strong>Max</strong>: LoopVectorization.jl 1.12 compatibility</p> <li><p><strong>Jaden</strong>: Optimization.jl base split work</p> <li><p><strong>Aayush</strong>: SymbolicUtils v4.0 rewrite</p> <li><p><strong>Oscar</strong>: Numerics, preconditioner interface, nonlinear solve optimization</p> <li><p><strong>Chris</strong>: Architecture and coordination</p> </ul> <p>The result will be:</p> <ul> <li><p>Faster precompilation across the ecosystem</p> <li><p>Cleaner dependency graphs</p> <li><p>Static compilation support</p> <li><p>Type-stable symbolic manipulation</p> <li><p>More modular, maintainable code</p> </ul> <p>We hope you enjoyed this first SciML Developer Chat&#33; If you&#39;d like to see more of these casual development discussions, let us know. Future episodes could cover:</p> <ul> <li><p>Catalyst.jl developments with Torkel</p> <li><p>The new VerbosityChain logging system with Jaden </p> <li><p>Other behind-the-scenes work in SciML</p> </ul> <p>The goal is to share what&#39;s happening without the overhead of formal blog posts or waiting for JuliaCon. Think of it as the lazy way to share more information - and we mean that in the best possible way&#33;</p> <p>And as always, if you have questions or want to contribute, join us on the <a href="https://julialang.org/slack/">Julia Slack</a> or <a href="https://github.com/SciML">GitHub</a>.</p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>