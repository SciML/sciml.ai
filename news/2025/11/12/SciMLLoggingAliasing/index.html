<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title>Fine-Grained Control in SciML: Introducing SciMLLogging and Enhanced Aliasing</title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://docs.sciml.ai/SciMLBenchmarksOutput/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=fine-grained_control_in_sciml_introducing_scimllogging_and_enhanced_aliasing ><a href="#fine-grained_control_in_sciml_introducing_scimllogging_and_enhanced_aliasing" class=header-anchor >Fine-Grained Control in SciML: Introducing SciMLLogging and Enhanced Aliasing</a></h1> <p>The SciML ecosystem continues to evolve with tools that give you precise control over your scientific computing workflows. Two recent additions—SciMLLogging.jl and the enhanced aliasing specification system—address common pain points in large-scale simulations: managing output verbosity and optimizing memory usage. Together, they provide the granular control needed for production-grade scientific computing.</p> <h2 id=scimlloggingjl_verbosity_control_done_right ><a href="#scimlloggingjl_verbosity_control_done_right" class=header-anchor >SciMLLogging.jl: Verbosity Control Done Right</a></h2> <p>If you&#39;ve ever found yourself drowning in solver output or wishing you could selectively silence certain warnings while keeping others, SciMLLogging.jl is your answer. This new package brings hierarchical, fine-grained logging control to the entire SciML ecosystem.</p> <h3 id=why_scimllogging ><a href="#why_scimllogging" class=header-anchor >Why SciMLLogging?</a></h3> <p>Traditional logging approaches often force an all-or-nothing choice: either see everything or see nothing. In complex scientific workflows—where you might want algorithm selection warnings but not iteration progress, or vice versa—this granularity matters. SciMLLogging.jl provides structured message handling that integrates seamlessly with Julia&#39;s native logging system while adding the specificity scientific computing demands.</p> <h3 id=how_it_works_in_linearsolvejl ><a href="#how_it_works_in_linearsolvejl" class=header-anchor >How It Works in LinearSolve.jl</a></h3> <p>Let&#39;s look at a concrete example from LinearSolve.jl. The package defines a <code>LinearVerbosity</code> struct organized into three main groups: error control, performance, and numerical diagnostics.</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearSolve, SciMLLogging

<span class=hljs-comment ># Quick start: Use a preset configuration</span>
verbose = LinearVerbosity(Standard())  <span class=hljs-comment ># Balanced default</span>
solve(prob, verbose = verbose)

<span class=hljs-comment ># Or choose from other presets:</span>
LinearVerbosity(None())      <span class=hljs-comment ># All messages disabled</span>
LinearVerbosity(Minimal())   <span class=hljs-comment ># Only critical errors</span>
LinearVerbosity(Detailed())  <span class=hljs-comment ># Comprehensive debugging</span>
LinearVerbosity(All())       <span class=hljs-comment ># Maximum verbosity</span></code></pre> <p>The real power comes from fine-grained control over individual message categories:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Control entire groups at once</span>
verbose = LinearVerbosity(
    error_control = WarnLevel(),  <span class=hljs-comment ># Show all error-related warnings</span>
    numerical = InfoLevel(),       <span class=hljs-comment ># Show numerical diagnostics</span>
)

<span class=hljs-comment ># Or control individual fields</span>
verbose = LinearVerbosity(
    default_lu_fallback = WarnLevel(),     <span class=hljs-comment ># Warn about factorization fallbacks</span>
    blas_errors = ErrorLevel(),             <span class=hljs-comment ># Show BLAS errors</span>
    convergence_failure = WarnLevel(),      <span class=hljs-comment ># Warn about convergence issues</span>
    KrylovJL_verbosity = CustomLevel(<span class=hljs-number >1</span>),   <span class=hljs-comment ># Pass verbosity to Krylov.jl</span>
    condition_number = InfoLevel()          <span class=hljs-comment ># Show condition numbers</span>
)

<span class=hljs-comment ># Mix group and individual settings (individual overrides group)</span>
verbose = LinearVerbosity(
    numerical = Silent(),              <span class=hljs-comment ># Silence all numerical messages</span>
    blas_errors = WarnLevel()          <span class=hljs-comment ># Except BLAS errors</span>
)</code></pre> <p>Here&#39;s what this looks like in practice with a rank-deficient system:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearSolve

A = [<span class=hljs-number >1.0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>
     <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>
     <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span>
     <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>]  <span class=hljs-comment ># Singular matrix</span>
b = rand(<span class=hljs-number >4</span>)
prob = LinearProblem(A, b)

<span class=hljs-comment ># With warnings enabled:</span>
verbose = LinearVerbosity(default_lu_fallback = WarnLevel())
solve(prob, verbose = verbose)
<span class=hljs-comment ># ┌ Warning: LU factorization failed, falling back to QR factorization.</span>
<span class=hljs-comment ># │ `A` is potentially rank-deficient.</span>
<span class=hljs-comment ># └ @ LinearSolve</span>

<span class=hljs-comment ># Change to InfoLevel for informational messages instead</span>
verbose = LinearVerbosity(default_lu_fallback = InfoLevel())
solve(prob, verbose = verbose)
<span class=hljs-comment ># [ Info: LU factorization failed, falling back to QR factorization.</span>
<span class=hljs-comment >#         `A` is potentially rank-deficient.</span></code></pre> <h3 id=message_categories_in_linearsolvejl ><a href="#message_categories_in_linearsolvejl" class=header-anchor >Message Categories in LinearSolve.jl</a></h3> <p>LinearVerbosity organizes messages into semantically meaningful groups:</p> <p><strong>Error Control Group:</strong></p> <ul> <li><p><code>default_lu_fallback</code>: Notifications when falling back from specialized methods</p> <li><p><code>blas_errors</code>: Critical BLAS/LAPACK errors</p> <li><p><code>blas_invalid_args</code>: Argument validation failures</p> </ul> <p><strong>Performance Group:</strong></p> <ul> <li><p><code>no_right_preconditioning</code>: Messages about preconditioning choices</p> </ul> <p><strong>Numerical Group:</strong></p> <ul> <li><p><code>convergence_failure</code>: Iterative solver convergence issues</p> <li><p><code>solver_failure</code>: General solver failures</p> <li><p><code>max_iters</code>: Maximum iteration warnings</p> <li><p><code>condition_number</code>: Matrix conditioning information</p> <li><p><code>KrylovJL_verbosity</code>, <code>HYPRE_verbosity</code>, <code>pardiso_verbosity</code>: Pass-through verbosity to external solvers</p> <li><p><code>blas_info</code>, <code>blas_success</code>: BLAS operation diagnostics</p> </ul> <h3 id=for_package_developers ><a href="#for_package_developers" class=header-anchor >For Package Developers</a></h3> <p>Package developers emit structured messages using the <code>@SciMLMessage</code> macro:</p> <pre><code class="julia hljs"><span class=hljs-meta >@SciMLMessage</span>(<span class=hljs-string >&quot;LU factorization failed, falling back to QR factorization. &quot;</span> *
              <span class=hljs-string >&quot;`A` is potentially rank-deficient.&quot;</span>,
              verbose, :default_lu_fallback)

<span class=hljs-comment ># Dynamic messages with computed values:</span>
<span class=hljs-meta >@SciMLMessage</span>(verbose, :condition_number) <span class=hljs-keyword >do</span>
    <span class=hljs-string >&quot;Matrix condition number: <span class=hljs-subst >$(cond(A)</span>) for <span class=hljs-subst >$(size(A)</span>) matrix&quot;</span>
<span class=hljs-keyword >end</span></code></pre> <h3 id=advanced_logger_configuration ><a href="#advanced_logger_configuration" class=header-anchor >Advanced Logger Configuration</a></h3> <p>SciMLLogging.jl includes <code>SciMLLogger</code> for routing messages to files:</p> <pre><code class="julia hljs">logger = SciMLLogger(
    info_repl = <span class=hljs-literal >true</span>,
    warn_repl = <span class=hljs-literal >true</span>,
    warn_file = <span class=hljs-string >&quot;solver_warnings.log&quot;</span>
)

with_logger(logger) <span class=hljs-keyword >do</span>
    solve(prob, verbose = LinearVerbosity(Detailed()))
<span class=hljs-keyword >end</span></code></pre> <p>This captures all warnings to <code>solver_warnings.log</code> while displaying info and warnings in your REPL—perfect for auditing solver behavior in production systems or debugging long-running workflows.</p> <h2 id=aliasing_specification_memory_optimization_made_explicit ><a href="#aliasing_specification_memory_optimization_made_explicit" class=header-anchor >Aliasing Specification: Memory Optimization Made Explicit</a></h2> <p>While SciMLLogging gives you control over what you see, the aliasing specification system gives you control over how memory is managed. In large-scale simulations—especially those involving repeated solves in optimization loops or sensitivity analysis—memory allocation patterns can make or break performance.</p> <h3 id=understanding_aliasing ><a href="#understanding_aliasing" class=header-anchor >Understanding Aliasing</a></h3> <p>Aliasing in this context means allowing the solver to reuse &#40;alias&#41; input arrays rather than copying them. When you alias <code>u0</code>, for example, the solver might modify the array you passed in rather than allocating a fresh copy. This can significantly reduce memory pressure, but requires careful consideration of whether you need the original data intact.</p> <h3 id=the_problem-specific_approach ><a href="#the_problem-specific_approach" class=header-anchor >The Problem-Specific Approach</a></h3> <p>Every SciML problem type now has an associated <code>AbstractAliasSpecifier</code> that provides explicit control over which variables to alias. This problem-specific design ensures the API matches the semantics of each problem type:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq

<span class=hljs-comment ># For ODE problems:</span>
solve(prob, Tsit5(), alias = ODEAliasSpecifier(alias_u0 = <span class=hljs-literal >true</span>))

<span class=hljs-comment ># For linear systems:</span>
solve(prob, KrylovJL_GMRES(), alias = LinearAliasSpecifier(
    alias_A = <span class=hljs-literal >false</span>,  <span class=hljs-comment ># Keep A intact</span>
    alias_b = <span class=hljs-literal >true</span>    <span class=hljs-comment ># b can be modified</span>
))

<span class=hljs-comment ># For stochastic problems:</span>
solve(prob, SRIW1(), alias = SDEAliasSpecifier(
    alias_u0 = <span class=hljs-literal >true</span>,
    alias_jumps = <span class=hljs-literal >true</span>
))</code></pre> <h3 id=available_specifiers ><a href="#available_specifiers" class=header-anchor >Available Specifiers</a></h3> <p>The ecosystem includes tailored specifiers for each problem domain:</p> <ul> <li><p><strong><code>LinearAliasSpecifier</code></strong>: Control aliasing for coefficient matrices and vectors</p> <li><p><strong><code>ODEAliasSpecifier</code></strong>: Manage initial conditions, derivatives, and time stops</p> <li><p><strong><code>SDEAliasSpecifier</code></strong>: Extends ODE options with jump process aliasing</p> <li><p><strong><code>NonlinearAliasSpecifier</code></strong>: Optimize solution vector handling</p> <li><p><strong><code>OptimizationAliasSpecifier</code></strong>, <strong><code>BVPAliasSpecifier</code></strong>, <strong><code>DDEAliasSpecifier</code></strong>, <strong><code>SDDEAliasSpecifier</code></strong>: Domain-specific controls for their respective problem types</p> </ul> <h3 id=smart_defaults ><a href="#smart_defaults" class=header-anchor >Smart Defaults</a></h3> <p>The aliasing system is designed with safety and convenience in mind. When you set a field to <code>nothing</code>, the solver uses its own optimized default behavior:</p> <pre><code class="julia hljs"><span class=hljs-comment ># Let the solver decide about u0, but explicitly prevent aliasing of p</span>
solve(prob, alg, alias = ODEAliasSpecifier(alias_u0 = <span class=hljs-literal >nothing</span>, alias_p = <span class=hljs-literal >false</span>))</code></pre> <p>This flexibility means you can selectively optimize specific bottlenecks without micromanaging the entire solve process.</p> <h3 id=when_to_use_aliasing ><a href="#when_to_use_aliasing" class=header-anchor >When to Use Aliasing</a></h3> <p>Aliasing optimization becomes valuable in several scenarios:</p> <ol> <li><p><strong>Optimization loops</strong>: When solving the same problem structure repeatedly with different parameters</p> <li><p><strong>Memory-constrained systems</strong>: Large-scale problems where allocation overhead dominates</p> <li><p><strong>Sensitivity analysis</strong>: Multiple problem evaluations where intermediate results don&#39;t need preservation</p> <li><p><strong>Ensemble simulations</strong>: Parallel solves where each trajectory can safely modify inputs</p> </ol> <h3 id=best_practices ><a href="#best_practices" class=header-anchor >Best Practices</a></h3> <ol> <li><p><strong>Start with defaults</strong>: Let solvers determine aliasing behavior initially, only optimizing after profiling</p> <li><p><strong>Measure, don&#39;t assume</strong>: Use <code>@time</code> and memory allocation tracking to verify improvements</p> <li><p><strong>Beware of mutations</strong>: If you need the original arrays later, don&#39;t alias them</p> <li><p><strong>Profile your use case</strong>: Performance impacts vary significantly based on problem size and structure</p> </ol> <h2 id=the_bigger_picture ><a href="#the_bigger_picture" class=header-anchor >The Bigger Picture</a></h2> <p>SciMLLogging.jl and the aliasing specification system exemplify a broader philosophy in the SciML ecosystem: providing powerful defaults while exposing expert-level control when needed. Beginners can ignore both and get excellent performance with sensible logging. Experts can fine-tune every aspect of their workflow for production deployments.</p> <p>These additions also share a common design pattern: hierarchical, composable structures that integrate cleanly with the rest of SciML. Whether you&#39;re managing verbosity or memory, you use the same familiar keyword argument pattern that pervades the ecosystem.</p> <h2 id=getting_started ><a href="#getting_started" class=header-anchor >Getting Started</a></h2> <p>Both features are available now. SciMLLogging.jl is a standalone package:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Pkg
Pkg.add(<span class=hljs-string >&quot;SciMLLogging&quot;</span>)</code></pre> <p>The aliasing specification system is integrated directly into SciMLBase.jl, so if you&#39;re on the latest version, you already have it.</p> <p>For detailed documentation:</p> <ul> <li><p><a href="https://github.com/SciML/SciMLLogging.jl">SciMLLogging.jl repository</a></p> <li><p><a href="https://docs.sciml.ai/SciMLBase/dev/interfaces/Problems/#Aliasing-Specification">Aliasing specification docs</a></p> </ul> <p>We encourage you to experiment with these tools in your workflows. The granular control they provide can make the difference between a debugging nightmare and a smooth production deployment. As always, if you encounter issues or have suggestions, the SciML community is active on <a href="https://github.com/orgs/SciML/discussions">GitHub Discussions</a> and <a href="https://discourse.julialang.org/">Discourse</a>.</p> <p>Happy computing&#33;</p> <hr /> <p><em>Want to dive deeper? Check out the full <a href="https://docs.sciml.ai/">SciML documentation</a> for comprehensive guides on integrating these features into your scientific workflows.</em></p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>