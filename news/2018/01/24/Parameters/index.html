<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 4.0: Breaking Syntax Changes, Adjoint Sensitivity, Bayesian Estimation, and ETDRK4 </title> <header> <h1><b><center>SciML Open Source Scientific Machine Learning</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>﻿ In this release we have a big exciting breaking change to our API. We are taking a &quot;now or never&quot; approach to fixing all of the API cruft we&#39;ve gathered as we&#39;ve expanded to different domains. Now that we cover the space of problems we wish to solve, we realize many inconsistencies we&#39;ve introduced in our syntax. Instead of keeping them, we&#39;ve decided to do a breaking change to fix these problems.</p> <h1 id=important_breaking_changes ><a href="#important_breaking_changes">Important BREAKING CHANGES</a></h1> <p>There have been a lot of requests for the same breaking changes for a long time. Given the incoming Julia 1.0 and its breaking changes, we decided to follow suit and fix our syntax issues as well. In our next release we will finally be applying these breaking changes.</p> <h4 id=these_changes_are_live ><a href="#these_changes_are_live">These changes are live&#33;</a></h4> <p>To see what version you have, use <code>Pkg.status&#40;&quot;DifferentialEquations&quot;&#41;</code>. To stay on the previous version, use <code>Pkg.pin&#40;&quot;DifferentialEquations&quot;,v&quot;3.1.0&quot;&#41;</code>.</p> <p>Note that the <a href="https://docs.juliadiffeq.org/latest/index">latest docs</a> are live with the changes. The <a href="https://docs.juliadiffeq.org/release-3.2/">release-3.2 docs</a> still hold the old syntax if needed.</p> <h3 id=summary_of_the_changes ><a href="#summary_of_the_changes">Summary of the Changes</a></h3> <ol> <li><p>Mutation goes first, then dependent variables, then parameters, then independent variables. <code>f&#40;mutate, dependent variables, p/integrator, independent variables&#41;</code></p> <li><p>No more wrapping parameters into functors. Parameters are part of the problem.</p> <li><p>All functions will have access to the problem parameters <code>p</code>.</p> </ol> <p>For example, this means that the ODE syntax will be <code>f&#40;u,p,t&#41;</code> and <code>f&#40;du,u,p,t&#41;</code>. This is breaking, as your previous code will break. In addition, there is no deprecation warning which is possible for this transition, making it a little more difficult than most. The documentation is already live with the changes. The upgrade path is as follows:</p> <ul> <li><p>For any ODE/SDE function <code>f&#40;t,u&#41;</code>, it&#39;s now <code>f&#40;u,p,t&#41;</code></p> <li><p>For any ODE/SDE function <code>f&#40;t,u,du&#41;</code>, it&#39;s now <code>f&#40;du,u,p,t&#41;</code></p> <li><p>For any DAE function <code>f&#40;t,u,du,resid&#41;</code>, it&#39;s now <code>f&#40;resid,du,u,p,t&#41;</code></p> <li><p>For any DAE function <code>f&#40;t,u,du&#41;</code>, it&#39;s now <code>f&#40;du,u,p,t&#41;</code></p> <li><p>For any DDE function <code>f&#40;t,u,h,du&#41;</code>, it&#39;s now <code>f&#40;du,u,h,p,t&#41;</code></p> <li><p>For any DDE function <code>f&#40;t,u,h&#41;</code>, it&#39;s now <code>f&#40;u,h,p,t&#41;</code></p> <li><p>For any BVP boundary condition <code>bc&#40;resid,u&#41;</code>, it&#39;s now <code>bc&#40;resid,u,p,t&#41;</code></p> <li><p>For any RODE function <code>f&#40;t,u,W&#41;</code>, it&#39;s now <code>f&#40;u,p,t,W&#41;</code></p> <li><p>For any RODE function <code>f&#40;t,u,du,W&#41;</code>, it&#39;s now <code>f&#40;du,u,p,t,W&#41;</code></p> <li><p>For any Dynamical ODE function <code>f&#40;t,u,v,dv&#41;</code>, it&#39;s now <code>f&#40;dv,v,u,p,t&#41;</code></p> <li><p>For any Dynamical ODE function <code>f&#40;t,u,v&#41;</code>, it&#39;s now <code>f&#40;v,u,p,t&#41;</code></p> <li><p>For any second order ODE function <code>f&#40;t,u,du,out&#41;</code>, it&#39;s now <code>f&#40;out,du,u,p,t&#41;</code></p> <li><p>For any second order ODE function <code>f&#40;t,u,du&#41;</code>, it&#39;s now <code>f&#40;du,u,p,t&#41;</code></p> <li><p>For any Hamiltonian <code>H&#40;q,p&#41;</code>, it&#39;s now <code>H&#40;p,q,params&#41;</code></p> <li><p>For any ODE Jacobian <code>f&#40;::Type&#123;Val&#123;:jac&#125;&#125;,t,u,J&#41;</code>, it&#39;s now <code>f&#40;::Type&#123;Val&#123;:jac&#125;&#125;,J,u,p,t&#41;</code></p> <li><p>For any DAE Jacobian <code>f&#40;::Type&#123;Val&#123;:jac&#125;&#125;,t,u,du,gamma,J&#41;</code>, it&#39;s now <code>f&#40;::Type&#123;Val&#123;:jac&#125;&#125;,J,du,u,p,gamma,t&#41;</code></p> <li><p>For any jump rates <code>rate&#40;t,u&#41;</code>, it&#39;s now <code>rate&#40;u,p,t&#41;</code></p> <li><p>For any callback condition <code>condition&#40;t,u,integrator&#41;</code>, it&#39;s now <code>condition&#40;u,t,integrator&#41;</code></p> <li><p><code>DDEProblem</code>s now use keyword arguments for the lags. The new construction syntax is:</p> </ul> <pre><code class="julia hljs">DDEProblem{isinplace}(f,u0,h,tspan,p=<span class=hljs-literal >nothing</span>;
                             constant_lags=<span class=hljs-literal >nothing</span>,
                             dependent_lags=<span class=hljs-literal >nothing</span>,
                             mass_matrix=<span class=hljs-literal >I</span>,
                             neutral = mass_matrix == <span class=hljs-literal >I</span> ?
                                       <span class=hljs-literal >false</span> : det(mass_matrix)!=<span class=hljs-number >1</span>,
                             callback = <span class=hljs-literal >nothing</span>)</code></pre> <ul> <li><p>State-dependent delay lags <code>lag&#40;t,u&#41;</code> are now <code>lag&#40;u,p,t&#41;</code></p> <li><p><code>DDEProblem</code> history functions now use keyword arguments for <code>idxs</code> to match the interpolation of standard solution types.</p> <li><p><code>DAEProblem</code>s now flip to <code>du0,u0</code> to match the way the arguments show in the function. The construction syntax is now:</p> </ul> <pre><code class="julia hljs">DAEProblem{isinplace}(f,du0,u0,tspan,p=<span class=hljs-literal >nothing</span>;
                      callback = <span class=hljs-literal >nothing</span>,
                      differential_vars = <span class=hljs-literal >nothing</span>)</code></pre> <ul> <li><p>For any <code>@ode_def</code> definition, the function no longer holds the parameters. For example,</p> </ul> <pre><code class="julia hljs">g = <span class=hljs-meta >@ode_def</span> LorenzExample <span class=hljs-keyword >begin</span>
  dx = σ*(y-x)
  dy = x*(ρ-z) - y
  dz = x*y - β*z
<span class=hljs-keyword >end</span> σ=&gt;<span class=hljs-number >28.0</span> ρ=&gt;<span class=hljs-number >10.0</span> β=&gt;<span class=hljs-number >8</span>/<span class=hljs-number >3</span></code></pre> <p>is now</p> <pre><code class="julia hljs">g = <span class=hljs-meta >@ode_def</span> LorenzExample <span class=hljs-keyword >begin</span>
  dx = σ*(y-x)
  dy = x*(ρ-z) - y
  dz = x*y - β*z
<span class=hljs-keyword >end</span> σ ρ β</code></pre> <p>This gets rid of the most repeated question &quot;why are some <code>&#61;&gt;</code> and others <code>&#61;</code>?&quot;. Now it&#39;s only for parameters, instead just inline the constants.</p> <ul> <li><p>There&#39;s no need for <code>ParameterizedFunction&#40;f,p&#41;</code> to enclose parameters. To give parameters, now they are given to the problem. For example, for the ODEProblem, you can call</p> </ul> <pre><code class="julia hljs">ODEProblem(f,u0,tspan)</code></pre>
<p>and that will default to <code>p&#61;nothing</code>, while</p>
<pre><code class="julia hljs">ODEProblem(f,u0,tspan,p)</code></pre>
<p>will set the parameters as <code>p</code>.</p>
<p>However, there are many things that benefit from this:</p>
<ol>
<li><p>No more digging through documentation for the right way to add parameters.</p>

<li><p>Since there&#39;s one way to do parameters, it&#39;s always compatible with add-ons.</p>

<li><p>All of the explicit parameter functionality &#40;estimation, sensitivity, etc.&#41; had to deal with the many ways parameters could be implemented. This will make it more concise and less prone to bugs.</p>

<li><p>All functions have access to parameters now. Before, there were some omissions like boundary conditions and reaction rates couldn&#39;t use parameters. This led to weird edge cases in parameter inference which could not be dealt with.</p>

<li><p>This syntax extends to PDEs better. <code>f&#40;du,u,p,t,x,y,z&#41;</code>.</p>

<li><p>This syntax does mutation first. This is a Julia-wide convention except for the old DiffEq which followed the Fortran ODE solver convention. Now we can finally match the rest of the Julia ecosystem and style guide.</p>

<li><p>People will no longer be confused about the case to use <code>@ode_def</code>. Now you can see it&#39;s explicitly for the syntax and the automatic Jacobian calculations, but not required for any use of parameters.</p>

<li><p>This opens up the possibility to have an option to pass the <code>integrator</code> as <code>p</code> in the near future, which then gives you access to all sorts of wild controls.</p>

</ol>
<p>These issues are what tripped up more people over time than anything else, so while this is a breaking change that will require work from everyone, we hope that the dust will settle in about 2 weeks and everything will go forward with a syntax that will persist and be well-liked.</p>
<h2 id=etdrk4 ><a href="#etdrk4">ETDRK4</a></h2>
<p>The ETDRK4 algorithm is a high order exponential integrator typically used in pseudospectral discretizations of partial differential equations like the Navier-Stokes equation. OrdinaryDiffEq.jl now contains a numerically-stable version which specializes on the chosen operator types to be efficient for many types of PDE discretizations. We will be featuring a blog post soon which highlights how this &#40;and other related tools&#41; can be used as central tools for solving PDEs in Julia. More on this to come.</p>
<h2 id=documentation_faq ><a href="#documentation_faq">Documentation FAQ</a></h2>
<p>The documentation now has <a href="https://docs.juliadiffeq.org/latest/basics/faq">a FAQ page</a>. It explains a lot of things like how to optimize your code, how to build complicated models, and how to diagnose and handle numerical errors. Please use this guide and request new additions as necessary&#33;</p>
<h2 id=adjoint_sensitivity_analysis ><a href="#adjoint_sensitivity_analysis">Adjoint Sensitivity Analysis</a></h2>
<p>Adjoint sensitivity analysis lets you directly solve for the derivative of some functional of the differential equation solution, such as a cost function in an optimization problem. <a href="https://docs.juliadiffeq.org/latest/analysis/sensitivity">DifferentialEquations.jl now has a package-independent adjoint sensitivity analysis implementation</a> that lets you use any of the common interface ODE solvers to perform this analysis. While there are more optimizations which still need to be done in this area, this will be a useful feature for those looking to perform optimization on the ODE solver.</p>
<h2 id=generalized_maximum_likelihood_fitting ><a href="#generalized_maximum_likelihood_fitting">Generalized Maximum Likelihood Fitting</a></h2>
<p>Our parameter inference methods previously relied on a distance-based cost function approach. While L2-error of the solution against data corresponds to maximum likelihood estimation under the assumption of a Normal likelihood, this is constrained to very specific likelihood functions &#40;Normal&#41;. Now our tools allow for giving a likelihood distribution associated with each time point. <a href="https://docs.juliadiffeq.org/latest/analysis/parameter_estimation">We have some examples in the documentation showing how to use MLE estimation to get fitting distributions</a>. This process is a more precise approach to data fitting and thus should be an interesting new tool to use in cases where one wants to fit parameters against a lot of data.</p>
<h2 id=bayesian_parameter_inference ><a href="#bayesian_parameter_inference">Bayesian Parameter Inference</a></h2>
<p>This release introduces a new library, DiffEqBayes.jl, which allows for Bayesian parameter estimation. Right now there are two inference functions. <code>stan_inference</code> requires that your function is defined via <code>@ode_def</code> and will write and run a code from <a href="https://mc-stan.org/">Stan</a> to generate posterior distributions. The <code>turing_inference</code> function uses <a href="https://github.com/yebai/Turing.jl">Turing.jl</a> and can work with any DifferentialEquations.jl object. These functions simply require your <code>DEProblem</code>, data, and prior distributions and the <a href="https://docs.juliadiffeq.org/latest/analysis/parameter_estimation">rest of the inference setup is done for you</a>. Thus this is a very quick way to make use of the power of Bayesian inference tools&#33;</p>
<h2 id=small_problem_speedups ><a href="#small_problem_speedups">Small Problem Speedups</a></h2>
<p>We keep speeding up the &quot;small problem case&quot;, which is solving problems which take on the order of microseconds. This required reducing the cost of adaptivity and being smarter in the setup routines. While this doesn&#39;t effect any decently long running code, it&#39;ll be helpful for parameter estimation with quick functions which have to be solved thousands to millions of times.</p>
<h1 id=upcoming_events ><a href="#upcoming_events">Upcoming Events</a></h1>
<p>The following JuliaDiffEq-related events are coming up:</p>
<h2 id=diffeq_tutorial ><a href="#diffeq_tutorial">DiffEq Tutorial</a></h2>
<p>There will be a <a href="https://www.youtube.com/watch?v&#61;KPEqYtEd-zY">live Youtube tutorial February 6th at 10AM PST</a>. This is to introduce users to DiffEq and for people to ask questions about getting started. It will focus mostly on how to solve ODEs, with some foreys into more difficult differential equations. We will be walking through the new syntax and parameter usage. You&#39;re encouraged to come join us, and if you&#39;re an expert it&#39;s always nice to have someone answering questions in the chat&#33;</p>
<h2 id=socal_julia_meetup ><a href="#socal_julia_meetup">SoCal Julia Meetup</a></h2>
<p>On <a href="https://www.meetup.com/Southern-California-Julia-Users/events/247130330/">Febraury 8th at 7PM PST</a> we will be having a SoCal Julia meetup at the University of California, Irvine. Katharine Hyatt will be giving a talk with titled &quot;Using Julia to Develop New Methods for Non-Equilibrium Statistical Mechanics&quot;. Additionally, Chris Rackauckas will be giving a talk titled &quot;How Multiprecision Leads to More Efficient and More Robust PDE Solvers&quot;. If you are in the area and would like to give a talk, please contact the organizers.</p>
<h1 id=in_development ><a href="#in_development">In development</a></h1>
<p>Please take a look at <a href="https://sciml.ai/soc/projects/diffeq.html">possible GSoC projects</a>. Please get in touch with us if you&#39;re interested in working on numerical differential equation solvers&#33;</p>
<p>Putting those aside, this is the main current &quot;in development&quot; list:</p>
<ul>
<li><p>Preconditioner choices for Sundials methods</p>

<li><p>Small feature requests &#40;for changing initial conditions, etc.&#41;</p>

<li><p>Improved jump methods &#40;tau-leaping&#41;</p>

<li><p>Adaptivity in the MIRK BVP solvers</p>

<li><p>More general Banded and sparse Jacobian support &#40;outside of Sundials&#41;</p>

<li><p>IMEX</p>

<li><p>Improved jump methods &#40;tau-leaping&#41;</p>

<li><p>Compiling Sundials with KLU and SuperLUMT</p>

<li><p>LSODA integrator interface</p>

</ul>
<div class=page-foot >
  <div class=copyright >
    Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language.
  </div>
</div>
</div>