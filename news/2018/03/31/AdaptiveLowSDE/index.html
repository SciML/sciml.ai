<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 4.2: Krylov Exponential Integrators, Non-Diagonal Adaptive SDEs, Tau-Leaping </title> <header> <h1><b><center>SciML Open Source Scientific Machine Learning</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>This is a jam packed release. A lot of new integration methods were developed in the last month to address specific issues of community members. Some of these methods are one of a kind&#33;</p> <h2 id=krylov_exponential_integrators ><a href="#krylov_exponential_integrators">Krylov Exponential Integrators</a></h2> <p>Normally, to solve stiff ODEs you need to solve implicit equations at every time step. However, when an equation is semilinear &#40;<code>u&#39; &#61; Au &#43; f&#40;t,u&#41;</code>&#41; then you can get away with solving a matrix exponential instead. If the system is small enough, then you can solve for this matrix exponential once, store it, and then utilize it each step. This is efficient, but is not always possible since even if <code>A</code> is sparse, <code>exp&#40;A&#41;</code> can be dense.</p> <p>To get around this issue, the ability to solve for matrix-vector products <code>exp&#40;gamma*A&#41;*v</code> without forming the matrix exponential is required. This can be done by Krylov subspace methods as seen in <a href="https://github.com/acroy/Expokit.jl">ExpoKit.jl</a> and <a href="https://github.com/marcusps/ExpmV.jl">Expmv.jl</a>. Xingjian Guo &#40;@MSeeker1340&#41; has developed routes in the exponential integrators of OrdinaryDiffEq.jl to utilize these Krylov subspace methods and allow for solving large stiff semilinear ODEs and allow for investigating adaptive time stepping exponential integrators. <a href="https://docs.juliadiffeq.org/latest/solvers/split_ode_solve">The methods all have a boolean option to turn this feature on</a>. For example:</p> <pre><code class="julia hljs">LawsonEuler(krylov=<span class=hljs-literal >true</span>, m=<span class=hljs-number >50</span>)</code></pre>
<p>enables the sparse form.</p>
<h2 id=adaptive_time_stepping_in_implicit_euler-heun_for_sdes ><a href="#adaptive_time_stepping_in_implicit_euler-heun_for_sdes">Adaptive Time Stepping in &#40;Implicit&#41; Euler&#40;-Heun&#41; for SDEs</a></h2>
<p>This is a huge update to unpack. The issue with our offering before is that we didn&#39;t have much for non-diagonal noise. This release upgrades the previous methods to make them much nicer for this domain.</p>
<p>First of all, you may have noticed that implicit solvers are pretty much worthless on highly stiff equations without adaptive time stepping. What happens is that the Newton iterations diverge when your initial guess is too far, and you have to change the time step to get around that&#33; This made the <code>ImplicitEM</code>, <code>ImplicitEulerHeun</code>, and <code>ImplicitRKMil</code> methods not perform so well on many equations that one would have expected them to do better.</p>
<p>However, these methods have all been retrofitted with error estimators to have adaptive time stepping. These error estimators are heuristics based off of the next expansion coefficients and tend to work surprisingly well. Note that these methods are semi-drift implicit so there are still equations that can trip them &#40;or any drift-impilict SDE integrator&#41; up. However, for most of the stiff problems people encounter these should be very useful. These can handle the whole range of noise forms from diagonal and scalar to non-diagonal. These methods now default to being adaptive.</p>
<p>The implicit methods weren&#39;t the only ones that got upgrades. These error estimators were modified to not utilize the Jacobian so they could cheaply be put to use on the <code>EM</code>, <code>EulerHeun</code>, <code>RKMil</code>, and <code>RKMilCommute</code> methods. The <code>RKMil</code> and <code>RKMilCommute</code> methods required no extra caches for the adaptivity so it was made the new default. For <code>EM</code> and <code>EulerHeun</code> this causes an increase in cache size and thus the adaptive versions were created as new methods <code>LambaEM</code> and <code>LambaEulerHeun</code>.</p>
<p>Thus DifferentialEquations.jl was not just the first openly available software with high order adaptive algorithms for SDEs, but also the first with adaptive algorithms for non-diagonal SDEs &#40;and high order for commutative SDEs&#41;, both stiff and non-stiff. Because defaults were changed on some of the methods, this was a breaking change and go a major version update.</p>
<p>That said, there&#39;s still some tweaking to be done. From quick testing the adaptivity parameters seem too conservative, and so some of the PI-control gains should be adjusted. On some test problems this made it take 5x less steps, but the safety of that technique needs to be investigated in more detail before making it default. <a href="https://github.com/JuliaDiffEq/StochasticDiffEq.jl/issues/62">The issue can be tracked here</a>.</p>
<h2 id=fixed_time_step_multistep_ode_methods ><a href="#fixed_time_step_multistep_ode_methods">Fixed Time Step Multistep ODE Methods</a></h2>
<p>Multistep methods require fewer function evaluations than one-step methods like Runge-Kutta and thus are more effective for large systems and when the derivative function <code>f</code> gets costly. <a href="https://docs.juliadiffeq.org/latest/solvers/ode_solve">OrdinaryDiffEq.jl now has some fixed time step methods of this class</a> and hopefully in the near future we will get our own adaptive time adaptive order versions. Thank the new contributor Shubham Maddhashiya &#40;@sipah00&#41; for this contribution and stay tuned.</p>
<h2 id=optimized_ssastepper ><a href="#optimized_ssastepper">Optimized SSAStepper</a></h2>
<p>Before, with pure-jump problems we recommended the <code>FunctionMap</code> algorithm for the solver. However, the <code>FunctionMap</code> algorithm utilizes the full OrdinaryDiffEq.jl integrator interface. In cases where the pure-jump problem doesn&#39;t have events, this is overkill and adds some overhead. Thus for this specific case &#40;pure-jumps and no events&#41;, we created the <code>SSAStepper</code>. You can see it now <a href="https://docs.juliadiffeq.org/latest/tutorials/discrete_stochastic_example">featured in the tutorials</a>. This stepper is highly efficient and benchmarks faster than other pure-Julia SSA implementations. Thus it allows you to have full efficiency in the pure-jump case while making it easy to bridge over to mixing ODEs/SDEs in via the same interface.</p>
<h2 id=regularjumps_and_tau-leaping ><a href="#regularjumps_and_tau-leaping">RegularJumps and Tau-Leaping</a></h2>
<p>DifferentialEquations.jl&#39;s <code>ConstantRateJump</code> and <code>VariableRateJump</code> are highly flexible allowing you to do lots of weird things like resizing after Poisson jumps. However, in order to implement different kinds of solvers we realized that we needed to pull back on the flexibility. But these solvers would be highly specific to the existence of jumps, so it makes sense to create a new jump type for them. This is the <code>RegularJump</code>. A <code>RegularJump</code> has a function that computes the vector of all rates together, and computes the effect on every system component due to each jump together &#40;as a matrix&#41;. You can see this <a href="https://docs.juliadiffeq.org/latest/tutorials/discrete_stochastic_example">in the tau-leaping version of the jump problem tutorial</a>. Right now there&#39;s just methods for pure <code>RegularJump</code> problems as shown in <a href="https://docs.juliadiffeq.org/latest/solvers/jump_solve">a new solver page</a>, but the plan is to add methods with high order regular stepping for jump diffusions a la Platen, and other pure jump integrators like Binomial leaping.</p>
<h2 id=history_function_parameters ><a href="#history_function_parameters">History Function Parameters</a></h2>
<p>There was a breaking change to the delay differential equation interface. David Widmann &#40;@devmotion&#41; noticed that the history functions did not get the parameter update of the other functions. Now the history functions are of the form <code>h&#40;p,t&#41;</code>, <code>h&#40;out,p,t&#41;</code>, etc. so they can depend on the parameters as well. This is a breaking change and received a major version update.</p>
<h2 id=event_handling_fixes ><a href="#event_handling_fixes">Event Handling Fixes</a></h2>
<p>In this release the event handling was reformed to be more robust for small step sizes. It should be more accurate at detecting events which are nearby the step of a previous event.</p>
<h1 id=in_development ><a href="#in_development">In development</a></h1>
<p>This release is packaged with a bunch of goodies, but stay tuned for the next release. Soon we will be releasing the first multi-paradigm automatic stiffness detection and switching algorithms since LSODA &#40;1983&#41; &#40;that we know of&#41;, picking right up where the masters left it by incorporating more efficient higher order methods. In addition there will be a large set of new SDE solvers dropping within the next month.</p>
<p>Additionally, this is the main current &quot;in development&quot; list:</p>
<ul>
<li><p>Preconditioner choices for Sundials methods</p>

<li><p>Adaptivity in the MIRK BVP solvers</p>

<li><p>More general Banded and sparse Jacobian support outside of Sundials</p>

<li><p>IMEX methods</p>

<li><p>Function input for initial conditions and time span &#40;<code>u0&#40;p,t0&#41;</code>&#41;</p>

<li><p>LSODA integrator interface</p>

</ul>
<div class=page-foot >
  <div class=copyright >
    Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language.
  </div>
</div>
</div>