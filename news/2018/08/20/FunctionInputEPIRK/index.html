<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl 5.0: v1.0, Jacobian Types, EPIRK </title> <header> <h1><b><center>SciML</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>This marks the release of DifferentialEquations.jl. There will be an accompanying summary blog post which goes into more detail about our current state and sets the focus for the organization&#39;s v6.0 release. However, for now I would like to describe some of the large-scale changes which have been included in this release. Much thanks goes to the Google Summer of Code students who heavily contributed to these advances.</p> <h2 id=v07_and_v10_compatibility ><a href="#v07_and_v10_compatibility">v0.7 and v1.0 Compatibility</a></h2> <p>JuliaDiffEq is now considered to be on Julia v1.0. The libraries have had a compatibility update releases and now the master branches are being developed for v1.0. This means that all new features will be Julia v1.0-only, but v0.6 versions should continue to work. A lot of help came from GSoC student Yingbo Ma &#40;@YingboMa&#41;.</p> <p>The following is a list of user-facing breaking changes:</p> <ul> <li><p>The performance overloads are now changed. Instead of defining overloads like <code>f&#40;::Type&#123;Val&#123;:jac&#125;&#125;,J,u,p,t&#41;</code> for Jacobains, instead you define an <code>ODEFunction&#40;f,jac&#61;f_jac&#41;</code> where <code>f_jac</code> is the function <code>f_jac&#40;J,u,p,t&#41;</code>. The same overloads all exist but now are passed to build the <code>ODEFunction</code> which is then used by the solver. Things like <code>SDEFunction</code>, <code>DDEFunction</code>, etc. all work analogously. <a href="https://docs.juliadiffeq.org/latest/features/performance_overloads">These are documented in the <code>Jacobians and DiffEqFunctions</code> page of the documentation.</a> Mass matrices have also moved to the DiffEqFunction types.</p> <li><p><code>saveat</code> now only includes the end points if the end points are in the array of <code>saveat</code> time points. Before, if <code>tspan&#61;&#40;0.0,1.0&#41;</code> and <code>saveat&#61;&#91;0.5&#93;</code> it would have saved at <code>&#91;0.0,0.5,1.0&#93;</code>. Now it saves at <code>&#91;0.5&#93;</code>. <code>saveat&#61;0.5</code> still expands to the array <code>saveat&#61;&#91;0.0,0.5,1.0&#93;</code> and thus works the same.</p> </ul> <p>All other breaking changes are internal changes to the solver structures to support new features.</p> <h2 id=jacobian_types_sparse_banded_matrix-free_etc ><a href="#jacobian_types_sparse_banded_matrix-free_etc">Jacobian Types: Sparse, Banded, Matrix-Free, etc.</a></h2> <p>The whole ecosystem now has a way to utilize non-dense matrix types by providing a <code>jac_prototype</code> to the appropriate <code>AbstractDiffEqFunction</code> &#40;example: <code>ODEFunction</code>&#41;. This is a type which the solvers will use internally. For example, if you pass a sparse matrix than a sparse Jacobian with that sparsity structure is what will be used. Matrix types from other packages work: if you pass a <code>BandedMatrix</code> from BandedMatrices.jl then internally the solvers can utilize banded matrix solvers. Also, if you pass a lazy operator type which has <code>mul&#33;</code> defined, then this matrix-free representation of the Jacobian is what will be used in algorithms like <code>gmres</code>. Thus any AbstractMatrix or AbstractDiffEqOperator can now be used as the Jacobian type. Specific solvers will throw an error if they do not support that matrix type. OrdinaryDiffEq.jl and StochasticDiffEq.jl support any Julia matrix type while Sundials.jl supports dense, sparse, and banded matrices. More widespread support for more matrix types can now be the subject of easy development since this interface is all setup thanks to GSoC student Xingjian Guo &#40;@MSeeker1340&#41;.</p> <h2 id=5th_stiff_order_epirk_methods ><a href="#5th_stiff_order_epirk_methods">5th &#40;Stiff&#41; Order EPIRK Methods</a></h2> <p>The EPRIK methods are a form of exponential integrator which works on any first order ODE and utilizes an adaptive Krylov method for efficient calculations of non-autonomous linear subproblems to approximate the solution. These methods can handle large stiff equations like PDE discretizations due to their stability properties, and the efficiency of the Krylov scheme has had recent ODE solver literature suggest that these could be some of the most efficient methods on large ODEs. this time around GSoC student Xingjian Guo &#40;@MSeeker1340&#41; added the 5th order methods, the highest order &#40;and potentially most efficient&#41; EPIRK methods which have been derived. We are the first ODE solver ecosystem to incorporate EPIRK methods into our suite, and so we will be performing some extensive testing to see if these claims hold. If they do, this would be a major efficiency gain to many potential DiffEq users.</p> <h2 id=adaptive_exponential-rosenbrock_methods ><a href="#adaptive_exponential-rosenbrock_methods">Adaptive Exponential-Rosenbrock methods</a></h2> <p>Like the EPIRK methods, the Exponential-Rosenbrock methods are exponential integrators which work directly on first order ODEs and utilize the Krylov methods to be efficient solvers for stiff equations. However, the methods allow time stepping adaptivity unlike the EPIRK methods, meaning that not <code>dt</code> needs to be given and these can be standard DiffEq-wide defaults due to their minimal necessary user input. More testing will be required to show if these methods should replace any of the default implicit methods as default methods given by <code>solve</code>. This again is the work of the wonderful GSoC student Xingjian Guo &#40;@MSeeker1340&#41;</p> <h2 id=quasi-constant_stepsize_variable_order_bdf_and_ndf_integrators ><a href="#quasi-constant_stepsize_variable_order_bdf_and_ndf_integrators">Quasi-Constant Stepsize Variable Order BDF and NDF Integrators</a></h2> <p>GSoC student Shubham Maddhashiya &#40;@sipah00&#41; has completed the implementation of the variable order quasi-constant time step NDF and BDF integrators. This is the implementation of multistep methods which is better known as GEAR, LSODE, or <code>ode15s</code> where a variable time step BDF method is constructed by interpolation to a new step size grid. This is done with the accuracy-increasing kappa&#39;s of Shampine to allow for larger step sizes. This is a full-Julia implementation in OrdinaryDiffEq.jl, so it will allow the use of arbitrary Julia types like arbitrary precision and complex numbers, though some of the extra features do need tests. And these still need some extensive benchmarking. But they are implemented and these finishing touches are much simpler to do over time.</p> <p>This is an interesting moment for us because this is the last main feature you would expect in any other integrator library, making the native Julia solvers of DifferentialEquations.jl a true superset of the ODE libraries like MATLAB ODE suite, SciPy, etc.</p> <h2 id=imex_bdf_integrators ><a href="#imex_bdf_integrators">IMEX BDF Integrators</a></h2> <p>The SBDF integrators are IMEX &#40;implicit-explicit&#41; methods which decrease the computational cost on the BDF integrator by allowing non-stiff portions of the equation to be integrated explicitly. GSoC student Shubham Maddhashiya &#40;@sipah00&#41; has contributed both implementations of the SBDF methods. These methods are described in the literature as core for handling large PDEs, yet this is the first set of open source implementations.</p> <h2 id=functional_initial_conditions_and_timespans ><a href="#functional_initial_conditions_and_timespans">Functional initial conditions and timespans</a></h2> <p>This is a feature that has been slated to be added for a long time. Now the initial condition to your differential equation problems do not have to just be constant values. For example, you can give a function <code>u0&#40;p,t0&#41;</code> and this will be evaluated using the parameters and starting time point in order to generate the <code>u0</code> as necessary. Additionally, if <code>u0</code> returns a <code>Distributions.jl</code> distribution, a solution will be taken by sampling from the initial distribution. By using this setup we will be able to do things like track sensitivity to initial condition in local sensitivity schemes. This has been a long requested feature and therefore we are happy to have a solution which is able to apply this similarly to all of the solvers.</p> <p>The structures that this allows may be more important than the feature itself. This was an often requested feature by library developers who wanted alternative APIs. For example, this allows you to pass a single number for the timespan and have it expand to <code>&#40;0,X&#41;</code>. <code>nothing</code> timespans are allowed and then a user must pass a timespan at the <code>solve</code> command. Additionally, passing an algorithm via <code>alg</code> will place it into the dispatching <code>solve&#40;prob,alg;kwargs...&#41;</code> position automatically, helping package authors handle this common case where it&#39;s lumped into the splatted kwargs passed down to an internal DiffEq call &#40;note it needs to be a positional algorithm for the dispatch mechanism to work, so at least as of Julia v1.0 it cannot be a keyword argument in general but this will allow it to act like one&#41;.</p> <p>Additionally, this let&#39;s us place a global type-checking system. There are some known type trip-ups which can occur. For example, using an adaptive ODE algorithm is incompatible with time as integers. If you use an adaptive ODE algorithm with initial conditions being dual numbers, you need time to be in dual numbers as well. The infrastructure of this change allows us to throw warnings in these cases to alert users to potential problems. By mixing this with Requires.jl, we can alert problems due to interactions with 3rd party packages as well, which will allow the informal knowledge about package ecosystem interactions to get formally encoded and automatically utilized. We hope that this will increase the usability of the software.</p> <h2 id=an_n-body_problem_solver_package_for_astrodynamics_and_molecular_dynamics ><a href="#an_n-body_problem_solver_package_for_astrodynamics_and_molecular_dynamics">An N-Body Problem Solver Package for Astrodynamics and Molecular Dynamics</a></h2> <p><a href="https://github.com/JuliaDiffEq/NBodySimulator.jl">NBodySimulator.jl</a> was built by GSoC student Mikhail Vaganov &#40;@Mikhail-Vaganov&#41;. It was a large endeavor and it includes tooling to easily create N-body problems with different potential functions &#40;gravitational, electric, etc.&#41; along with all of the pieces analysis methods for calculating temperature, pressure, etc. There will be a separate blog post introducing this cool and I don&#39;t want to steal its thunder so that&#39;s all we&#39;ll post for now&#33;</p> <h2 id=stabilized-explicit_methods ><a href="#stabilized-explicit_methods">Stabilized-Explicit Methods</a></h2> <p>Stabilized explicit methods are explicit Runge-Kutta methods with high stage numbers that are chained together to give a stable method for semi-stiff differential equations. New contributor Yongfei Tan &#40;@tyfff&#41; with the help of Yingbo Ma &#40;@YingboMa&#41; implemented our first stabilized explicit method, the <code>ROCK2</code> algorithm. Since these are chained Runge-Kutta methods, no linear algebra is involved meaning that these methods can be compatible with all of the features that the basic Runge-Kutta methods are, giving us an easy avenue to support units, arbitrary array types, etc. in a method for stiff ODEs. These methods are also low storage: instead of storing the Jacobian O&#40;n^2&#41; &#40;unless sparse Jacobians are specified&#41;, these methods store O&#40;n&#41; by default, allowing them to be a nice default for large stiff systems when no sparsity structure is defined &#40;and a dense Jacobian would not fit into memory&#41;. This is an exciting area&#33;</p> <h1 id=in_development ><a href="#in_development">In development</a></h1> <p>And here&#39;s a quick view of the rest of our &quot;in development&quot; list:</p> <ul> <li><p>Preconditioner choices for Sundials methods</p> <li><p>Adaptivity in the MIRK BVP solvers</p> <li><p>LSODA integrator interface</p> <li><p>Fixed Leading Coefficient &#40;FLC&#41; form Nordsieck BDF integrators.</p> </ul> <h1 id=projects ><a href="#projects">Projects</a></h1> <p>Are you a student who is interested in working on differential equations software and modeling? If so, please get in touch with us since we may have some funding after August for some student developers to contribute towards some related goals. It&#39;s not guaranteed yet, but getting in touch never hurts&#33;</p> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>