<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title> DifferentialEquations.jl 2.0 </title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://benchmarks.sciml.ai/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><p>ï»¿</p> <h1 id=differentialequationsjl_20 ><a href="#differentialequationsjl_20" class=header-anchor >DifferentialEquations.jl 2.0</a></h1> <p>This marks the release of ecosystem version 2.0. All of the issues got looked over. All &#40;yes all&#33;&#41; of the API suggestions that were recorded in issues in JuliaDiffEq packages have been addressed&#33; Below are the API changes that have occurred. This marks a really good moment for the JuliaDiffEq ecosystem because it means all of the long-standing planned API changes are complete. Of course new things may come up, but there are no more planned changes to core functionality. This means that we can simply work on new features in the future &#40;and of course field bug reports as they come&#41;. A blog post detailing our full 2.0 achievements plus our 3.0 goals will come out at our one year anniversary. But for now I want to address what the API changes are, and the new features of this latest update.</p> <p>The main changes in 2.0 is that this finishes a lot of the fundamental design of DiffEq. Many new problems were added, and the existing problems were modified to accommodate a much larger domain of problems. This leaves the next developments in the ecosystem to be fleshing out the algorithms for solving all of the problem types.</p> <h1 id=api_changes ><a href="#api_changes" class=header-anchor >API Changes</a></h1> <p>This post is to detail the API changes that are happening in the DifferentialEquations.jl ecosystem. Most of them should not be very disruptive, but are things that you should take notice of.</p> <h2 id=solution_indexing_change ><a href="#solution_indexing_change" class=header-anchor >Solution indexing change</a></h2> <p>The solution object now indexing has been changed to match Julian APIs better. The linear index <code>sol&#91;i&#93;</code> returning the value at the <code>i</code>th timepoint is the same. However, the &quot;matrix indexing&quot; has been flipped. Now, the <code>j</code>th component at timepoint <code>i</code> is given as <code>sol&#91;j,i&#93;</code> whereas before it was <code>sol&#91;i,j&#93;</code>. This means that <code>sol&#91;j,i&#93;&#61;&#61;sol&#91;i&#93;&#91;j&#93;</code>. The reason for this is that in our setup &quot;columns&quot; are timepoints, not across time. Given Julia&#39;s column-major format, this gave the wrong impression about contiguousness of the array.</p> <p>Now, the <code>DESolution</code> type is simply a subtype of the new <code>AbstractVectorOfArray</code> type in RecursiveArrayTools.jl. That means that, in addition to this change, many other features were added that make the solution type act more like an array.</p> <h2 id=save_timeseries_changed_to_save_everystep ><a href="#save_timeseries_changed_to_save_everystep" class=header-anchor ><code>save_timeseries</code> changed to <code>save_everystep</code></a></h2> <p>Many users were confused about what the <code>save_timeseries</code> argument did, so it was changed to <code>save_everystep</code>. Now it&#39;s clear that it means that every internal solver step is counted for saving. This can still be controlled by <code>timeseries_steps</code> to skip integer numbers of intervals.</p> <h2 id=saveat_no_save_everystep ><a href="#saveat_no_save_everystep" class=header-anchor ><code>saveat</code> &#61;&gt; no <code>save_everystep</code></a></h2> <p>Before, <code>save_everystep</code> always defaulted to true. However, this tripped up many users who were interested in saving the output at specific timepoints: why would the solver give me points I wasn&#39;t asking for when I was already saying what I wanted?</p> <p>To fix this, the default for <code>save_everystep</code> was changed to be whether <code>isempty&#40;saveat&#41;</code>. The result is that</p> <pre><code class="julia hljs">sol = solve(prob,alg,saveat=save_timepoints)</code></pre>
<p>is equivalent to what used to be</p>
<pre><code class="julia hljs">sol = solve(prob,alg,saveat=save_timepoints,save_everystep=<span class=hljs-literal >false</span>)</code></pre>
<p>Note that you can recover the previous default behavior by explicitly setting <code>save_everystep&#61;true</code>:</p>
<pre><code class="julia hljs">sol = solve(prob,alg,saveat=save_timepoints,save_everystep=<span class=hljs-literal >true</span>)</code></pre>
<p>We believe that this default should be more sensible to most users.</p>
<h2 id=saveat_using_numbers ><a href="#saveat_using_numbers" class=header-anchor ><code>saveat</code> using Numbers</a></h2>
<p>A common usage for <code>saveat</code> is to get out an evenly-spaced grid. For example, <code>0.0:0.1:1.0</code> if you want 10 evenly-spaced points. Actually, that has some floating point issues, so we thought it would be better to help you out.</p>
<pre><code class="julia hljs">sol = solve(prob,alg,saveat=<span class=hljs-number >0.1</span>)</code></pre>
<p>will now make the solver save at <code>tspan&#91;1&#93;:0.1:tspan&#91;2&#93;</code> timepoints. This should be a nice shorthand for a very standard operation.</p>
<h2 id=save_idxs ><a href="#save_idxs" class=header-anchor ><code>save_idxs</code></a></h2>
<p>A new argument was added which allows you to choose which indices to save. So far this is only implemented in the <code>*DiffEq</code> packages &#40;OrdinaryDiffEq.jl, StochasticDiffEq.jl, DelayDiffEq.jl&#41;, but can be made compatible with other solvers as well &#40;please open and issue if you would like to have this in Sundials.jl or other packages. Or a PR&#33; This isn&#39;t a difficult change&#33;&#41;. For example:</p>
<pre><code class="julia hljs">sol = solve(prob,alg,saveat=<span class=hljs-number >0.1</span>,save_idxs=<span class=hljs-number >1</span>:<span class=hljs-number >2</span>:<span class=hljs-number >5</span>)</code></pre>
<p>will save an array of three values &#40;dependent variables 1, 3, and 5&#41; at each <code>0.1</code> points in time. Note this can be used without <code>saveat</code>.</p>
<h2 id=save_start ><a href="#save_start" class=header-anchor ><code>save_start</code></a></h2>
<p>Another new output control. <code>save_start</code> notes whether the initial condition should be appended to the start of the solution type. This defaults as true, and most of the solver packages implement this option.</p>
<h2 id=callbacks_in_problems ><a href="#callbacks_in_problems" class=header-anchor >Callbacks in problems</a></h2>
<p>The problem types now can hold callbacks. This is to associate some behavior like events with the problem instead of the integrator. They do not act differently, and are just a <code>callback</code> keyword argument in the problem types.</p>
<h2 id=parameterizedfunctions ><a href="#parameterizedfunctions" class=header-anchor >ParameterizedFunctions</a></h2>
<p>Although there was discussions about changing the <code>@ode_def</code> macro syntax, I ultimately decided against it. Instead, I polished up the edges of ParameterizedFunctions and added to the documentation how you can do all of the things which users had issues about. Some of the functionality in there is new. There was a large change and an upgrade in the version of SymEngine that is used, so now more functions can be differentiated. Importantly, no <code>@eval</code>s are used anymore, and this means that in the future all of DifferentialEquations.jl can be statically compiled. But now this means that DifferentialEquations.jl can be precompiled.</p>
<p>As for where this is going next, ParameterizedFunctions is going to maintenance and bugfix mode. It seems everything that can be done in that architecture is done. All of the new cool ideas will become an <code>@diffeq</code> DSL in DiffEqDSL.jl. You can read the following issues for the plan:</p>
<p><a href="https://github.com/JuliaDiffEq/DiffEqDSL.jl/issues/1">https://github.com/JuliaDiffEq/DiffEqDSL.jl/issues/1</a> <a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl/issues/17">https://github.com/JuliaDiffEq/ParameterizedFunctions.jl/issues/17</a></p>
<p>It will be exciting, but will be separate from the current macro and thus you have no reason to expect breakage.</p>
<h1 id=new_features ><a href="#new_features" class=header-anchor >New Features</a></h1>
<h2 id=eulerheun_and_rkmil_interpretation ><a href="#eulerheun_and_rkmil_interpretation" class=header-anchor >EulerHeun and RKMil interpretation</a></h2>
<p>The <code>EulerHeun</code> method is our first SDE method for Stratonovich differential equations. We note that Ito vs Stratonovich is a difference in  the interpretation of the integral, not in the SDE itself. Thus there is no switch for &quot;choosing&quot; Ito vs Stratonovich &#40;or whatever else&#41;, instead it&#39;s just noted in the docs for which interpretation the integration technique converges.</p>
<p>For some methods, there are ways to make a different version compatible with different interpreations. So for example, we have in development an <code>interpretation</code> syntax for <code>RKMil</code>, where <code>RKMil&#40;interpretation&#61;:Stratonovich&#41;</code> converges with first-order in the Stratonovich sense &#40;defaults to <code>:Ito</code>&#41;. We hope to extend our support as time progresses.</p>
<h2 id=non-diagonal_noise ><a href="#non-diagonal_noise" class=header-anchor >Non-Diagonal Noise</a></h2>
<p>We finally accept a form of non-diagonal noise. For SDEs, you can give a <code>noise_rate_prototype</code> which will be the array for the <code>du</code> slot in the SDE&#39;s noise function <code>g</code>. This defaults to <code>nothing</code>, which will make <code>du</code> and array whose geometry matches <code>u</code> and does diagonal noise, that is <code>du.*dW</code>. However, when you specify <code>du</code>, it changes it do the standard form for noise: <code>du*dW</code>. This allows for commutative and non-commutative noise by specifying the array to be a matrix like <code>noise_rate_prototype&#61;rand&#40;n,m&#41;</code> where <code>m</code> is the Ito dimension &#40;number of independent Brownian motions&#41;, and it will automatically generate <code>dW</code> as a vector of size <code>m</code>.</p>
<p>Importantly, this works on any <code>AbstractMatrix</code>. So for example, if your reactions are sparse on the vector <code>dW</code>, you can choose <code>noise_rate_prototype&#61;sparse&#40;A&#41;</code>, some sparse matrix <code>A</code> which has the correct set of non-zeros for your problem, and then <code>du</code> will be that sparse matrix. Even special forms for the matrix, like <code>Tridiagonal</code>, are accepted. This means you can specify this in a way that is suitable to your problem yet retain efficiency by using specialized matrix types.</p>
<p>Currently only <code>EM</code> and <code>EulerHeun</code> are compatible with non-diagonal noise, but this area should be growing.</p>
<h2 id=noiseprocess_improvements ><a href="#noiseprocess_improvements" class=header-anchor >NoiseProcess Improvements</a></h2>
<p>A <code>NoiseProcess</code> is how you create colored noise in the SDE and RODE problems. In fact, it&#39;s general enough to create any noise process&#33; For example,</p>
<pre><code class="julia hljs">WienerProcess(t0,W0,Z0=<span class=hljs-literal >nothing</span>)
WienerProcess!(t0,W0,Z0=<span class=hljs-literal >nothing</span>)</code></pre>
<p>are used to build a <code>WienerProcess</code> either in its inplace form or in its out-of-place form. The resulting type <code>W</code> is designed to use the RSwM adaptivity algorithms to allow for very fast generation of the processes. In addition, the process is a condition function <code>W&#40;t&#41;</code> which will automatically interpolate at the necessary points. This allowed for the creation of a wrapper</p>
<pre><code class="julia hljs">NoiseWrapper(W::NoiseProcess)</code></pre>
<p>that lets you re-use the same noise process in a different stochastic simulation. In addition, you can also create spatial colored noise easily by passing in a constant covariance matrix:</p>
<pre><code class="julia hljs">CorrelatedWienerProcess(Î,t0,W0,Z0=<span class=hljs-literal >nothing</span>)
CorrelatedWienerProcess!(Î,t0,W0,Z0=<span class=hljs-literal >nothing</span>)</code></pre>
<p>The noise processes now have their own package DiffEqNoiseProcess.jl and the interface is documented so that way the creation of new types of noise processes can be done as needed.</p>
<h2 id=rodes ><a href="#rodes" class=header-anchor >RODEs</a></h2>
<p>Random Ordinary Differential Equations &#40;RODEs&#41; are a rapidly growing area where, for some stochsatic process <code>y&#40;t&#41;</code>, you have a differential equation:</p>
<pre><code class="julia hljs">u&#x27; = f(t,u,y)</code></pre>
<p>It can be shown that, under certain assumptions, SDEs are a form of RODE. There is a new problem type and our first integrator, <code>RandomEM&#40;&#41;</code>, which is the random Euler-Maruyama method. If no <code>NoiseProcess</code> is given, then <code>y&#40;t&#41;</code> defaults to white noise, and this converges to the Ito interpretation of the random integral.</p>
<p>More methods to come. One thing which will help will be the release of Kloeden&#39;s new book on methods for RODEs. This has the same compatibility throughout the ecosystem as SDEs, so it works for things like parameter estimation. We hope this exciting and one of a kind feature helps your research take new and interesting directions&#33;</p>
<h2 id=steady_state_calcuations ><a href="#steady_state_calcuations" class=header-anchor >Steady State Calcuations</a></h2>
<p>In many cases you want an easy way to calculate the steady states of a differential equation, that is the state <code>u</code> such that</p>
<pre><code class="julia hljs"><span class=hljs-number >0</span> = f(u)</code></pre>
<p>The new library DiffEqSteadyState.jl has solvers which make this simple. You can generate a new steady state problem from an <code>f</code> and an inital guess:</p>
<pre><code class="julia hljs">SteadyStateProblem(f,u0,mass_matrix=I)</code></pre>
<p>or directly convert an <code>ODEProblem</code> into a <code>SteadyStateProblem</code>:</p>
<pre><code class="julia hljs">SteadyStateProblem(prob::ODEProblem)</code></pre>
<p>This can then be solved using the new libraries solve function dispatch. Right now only <code>SSRootfind</code> is implemented, which will solve for the steady states using a rootfinding algorithm. However, we plan to implement accelerated methods specific for differential equations &#40;and partial differential equations&#41; that will speed up these calculations. In fact, a new algorithm for stochastic steady states may be coming as a new publication, with an implmentation here...</p>
<h2 id=complex_plotting ><a href="#complex_plotting" class=header-anchor >Complex Plotting</a></h2>
<p>This new update adds the recipe library DimensionalPlotRecipes.jl to the fray. This allows for complex numbers to be directly plotted, and many other controls are provided. We plan to extend this to work with Quaternions and allow for automatic dimensional reduction for high dimensional plots. Documentation for this can be found at the library&#39;s README and is now linked to in the DiffEq plotting section.</p>
<h2 id=monte_carlo_parallelism_types ><a href="#monte_carlo_parallelism_types" class=header-anchor >Monte Carlo Parallelism Types</a></h2>
<p>The Monte Carlo functionality now has support for different parallelism types, so you can tell it to parallelize using threading, pmap, <code>@parallel</code>, or no parallelism at all. Additionally, there is a <code>split_threads</code> option which will use threading separately on each process, allowing one to using threading on every node of a cluster for maximum performance.</p>
<h2 id=refined_problem_types ><a href="#refined_problem_types" class=header-anchor >&quot;Refined Problem Types&quot;</a></h2>
<p>This update introduces &quot;refined problem types&quot;. These are problem types which give the solver additional information. For example, a <code>SplitODEProblem</code> is of the form:</p>
<pre><code class="julia hljs">du = f1(t,u) + f2(t,u) + ... + fn(t,u)</code></pre>
<p>and the solvers can use the information from this split problem to have more optimized algorithms. Additionally, a partitioned form</p>
<pre><code class="julia hljs">du1 = f1(t,u1,u2,...,uN)
du2 = f2(t,u1,u2,...,uN)
...
dun = fn(t,u1,u2,...,un)</code></pre>
<p>which can be used for things like symplectic algorithms. The underlying machinery is the new type <code>ArrayPartition</code> in RecursiveArrayTools.jl and allows for heterogeneous types to be used with type-stable broadcasting. Notably, this means that second order problems:</p>
<pre><code class="julia hljs">u&#x27;&#x27; = f(t,u,u&#x27;)</code></pre>
<p>can be solved with the proper units without loss of efficiency &#40;once broadcast is used internally&#41;. Thus there are problem types for these new problems, including a helper type for <code>SecondOrderODEProblem</code>.</p>
<p>While there are not many algorithms implemented which use all of this yet, the machinery is all in place in OrdinaryDiffEq.jl, DelayDiffEq.jl, and StochasticDiffEq.jl, so implementing new algorithms which solve these types of problems is now easy. This will be the basis of some PDE algorithms as well.</p>
<h2 id=mass_matrices ><a href="#mass_matrices" class=header-anchor >Mass Matrices</a></h2>
<p>Mass matrices were added to the appropriate problem types. Most of the solvers don&#39;t support using them yet, but now all of the solvers have a way of recieving a user-defined mass matrix. Updates will come which will then make use of this functionality.</p>
<h2 id=linsolvenlsolve_choice ><a href="#linsolvenlsolve_choice" class=header-anchor >linsolve/nlsolve Choice</a></h2>
<p>Now one can explicitly choose the linear solver and nonlinear solver functions for each of the <code>*DiffEq</code> solvers. <a href="https://docs.juliadiffeq.org/latest/features/linear_nonlinear">This documentation page</a> explains how to do this. This means you can tell the linear solving to occur on the GPU, or using PETSc, etc., and replace the nonlinear solver code with one of your own choosing.</p>
<h2 id=full_v06_compatibility ><a href="#full_v06_compatibility" class=header-anchor >Full v0.6 Compatibility</a></h2>
<p>DifferentialEquations.jl is now compatible with Julia&#39;s v0.6. Additionally, the deprecation warnings have all been cleaned up &#40;except for the deprecation warnings from the dependencies NLsolve.jl and IterativeSolvers.jl... go bug them to merge my PRs and tag a new version if you want those depwarns gone :&#41;&#41;. This means that you should feel free to start using DifferentialEquations on v0.6 without a hitch.</p>
<p>But there is one caveat to mention. Plots.jl is not v0.6 compatible right now, and so you should stay on v0.5 until plotting is ready if that&#39;s a functionality that you need.</p>
<h1 id=near_future_changes ><a href="#near_future_changes" class=header-anchor >Near Future Changes</a></h1>
<p>These are changes which didn&#39;t quite make the 2.0 release, but will be coming soon after.</p>
<h2 id=full_precompilation ><a href="#full_precompilation" class=header-anchor >Full Precompilation</a></h2>
<p>Before, DifferentialEquations.jl could not be precompiled because anything related to ParameterizedFunctions.jl could not precompiled. This was due to the dynamic use of SymEngine.jl. However, SymEngine will release an update which makes this no longer necessary, and thus all of this can now be precompiled. The result is that the entirety of DiffEq will be precompile friendly. Not only that, it will be statically compliable.</p>
<h2 id=experimental_diffeqio ><a href="#experimental_diffeqio" class=header-anchor >Experimental: DiffEqIO</a></h2>
<p>IO functionality has been experimentally added through IterableTables.jl. This allows one to easily save solution types to DataFrames, CSVs, and more. This will be added to the documentation when it&#39;s out of the experimental phase.</p>
<h2 id=extensive_pde_tools ><a href="#extensive_pde_tools" class=header-anchor >Extensive PDE Tools</a></h2>
<p>This will be detailed in the follow-up post on the state of the ecosystem.</p>
<!-- Footer-->
<footer class="footer bg-light">
  <div class=container >
      <div class=row >
          <div class="col-lg-6 h-100 text-center text-lg-start my-auto">
              <ul class="list-inline mb-2">
                  
                  <li class=list-inline-item ><a href="/community">Contact</a>
                  <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a>
                  <li class=list-inline-item ><a href="#!">Privacy Policy</a> -->
              </ul>
              <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p>
              <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p>

            </div>
          <div class="col-lg-6 h-100 text-center text-lg-end my-auto">
              <ul class="list-inline mb-0">
                  <li class="list-inline-item me-4">
                      <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a>
                  
                  <li class="list-inline-item me-4">
                      <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a>
                  
                  <li class=list-inline-item >
                      <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a>
                  
              </ul>
          </div>
      </div>
  </div>
</footer>
</div>