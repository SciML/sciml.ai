<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://www.youtube.com/playlist?list=PLP8iPy9hna6QglWLQM02jcVjEBjaamzvw">Watch the recordings of SciMLCon 2022</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/dev/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="/challenge/">Challenges</a> <li class=nav-item > <a class=nav-link  href="https://benchmarks.sciml.ai/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/dev/">Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=sdirk_methods ><a href="#sdirk_methods" class=header-anchor >SDIRK Methods</a></h1> <p>This has been a very productive summer&#33; Let me start by saying that a relative newcomer to the JuliaDiffEq team, David Widmann, has been doing some impressive work that has really expanded the internal capabilities of the ordinary and delay differential equation solvers. Much of the code has been streamlined due to his efforts which has helped increase our productivity, along with helping us identify and solve potential areas of floating point inaccuracies. In addition, in this release we are starting to roll out some of the results of the Google Summer of Code projects. Together, there&#39;s some really exciting stuff&#33;</p> <h2 id=sdirk_methods__2 ><a href="#sdirk_methods__2" class=header-anchor >SDIRK Methods</a></h2> <p>In this update we made another big step forward in stiff solvers by adding SDIRK methods. SDIRK methods are singly-diagonal implicit Runge-Kutta methods for stiff ODEs. Being singly-diagonal, they require just a single matrix factorization. The solvers then exploit this fact to allow reusing the factorizing between steps and thus gaining efficiency. The result is some highly efficient methods for quasi-constant Jacobians.</p> <p>To highlight some of the new methods, the new <code>TRBDF2</code> scheme works surprisingly well in many areas. Although only second order, it has very good &quot;stage prediction&quot; which allows the nonlinear solver to converge in just a few steps even with reused Jacobians, making it extremely fast on the right problems. In problems where the Jacobian is expensive but is relatively constant, this method are the new champion. This was an area that Rosenbrock methods did not do as well before, and thus <code>CVODE_BDF</code> helps the crown in this domain. At the higher order end of the spectrum, methods like <code>Kvaerno5</code> and <code>KenCarp4</code> have similar results in the slow changing Jacobian domain but are efficient at achieving high accuracy.</p> <p>Thus, with the introduction of these SDIRK methods, we have been hard pressed to find problems where <code>CVODE_BDF</code> is not heavily surpassed by one of the OrdinaryDiffEq.jl methods. Sundials has now been relegated to the &quot;lowish accuracy huge PDEs&quot; niche. However, we will soon have an answer to that in the form of IMEX methods which will be explained below. In addition, most of the wrapped Fortran methods don&#39;t have a niche at all. The one wrapped method that we see as really filling a niche that we do not hit is <code>radau</code>. If you need to solve stiff equations with error <code>&lt;1e-7</code>, <code>radau</code> is still the method to go to.</p> <p>One piece of information to note is that <code>ImplicitEuler</code> and <code>Trapezoid</code> were revamped as part of this release. They are now considered SDIRK methods and use the same quasi-Newton method. Their old implementation which allowed user-defined nonlinear solvers is now kept as <code>GenericImplicitEuler</code> and <code>GenericTrapezoid</code>. However, in most cases the new versions tend to have massive performance increases.</p> <h2 id=two-stage_method_for_parameter_estimation ><a href="#two-stage_method_for_parameter_estimation" class=header-anchor >Two-Stage Method for Parameter Estimation</a></h2> <p>This comes from the parameter estimation Google Summer of Code project. The two-stage method is a method which finds optimal parameters for a differential equation from timeseries data. By using smoothed regressions, it&#39;s able to get approximate parameter values without having to repeatedly solve the ODE and thus is very efficient. This method thus can be a good first stage in an estimation routine to help you pinpoint the general region of parameter space to then finish exploring with the more direct methods.</p> <h2 id=regularization_in_parameter_estimation ><a href="#regularization_in_parameter_estimation" class=header-anchor >Regularization in Parameter Estimation</a></h2> <p>Regularization is used to make it easier to converge to a slightly biased solution. Not much more to say than you can now pass any penalty function from PenaltyFunctions.jl to add it to the loss functions in the parameter estimation routines. This should help the routines converge much better when there are large numbers of possibly underdetermined parameters.</p> <h2 id=broadcast_gpu_compatibility ><a href="#broadcast_gpu_compatibility" class=header-anchor >Broadcast: GPU Compatibility</a></h2> <p>We have internal broadcasting a lot of places. Not all, but lots. We identified where issues are &#40;12&#43; broadcasts leads to a performance regression, so we marked all of these and filed an issue in the Julia language repository&#41; and upgraded everything that didn&#39;t cause performance regressions. The result? Methods which now fully broadcast can handle <code>AbstractArray</code>s very well. How well? Take for example GPUArrays.jl. These make arrays on the GPU of course. However, you do not want to index them since getting single values from the GPU is expensive. But broadcasted operations are performed in GPU kernels and so they are very fast if used on large enough problems. Also, BLAS operations like matrix multiplication are performed on the GPU, so they are fine. <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl/issues/176#issuecomment-320821901">Quick tests shows this works</a>.</p> <p>Now what can this do? If you put a few arrays into an <code>ArrayPartition</code>, then you can define equations which are just broadcasting between these GPUArrays without ever indexing any of them. I&#39;ve used this to defined a system of reaction-diffusion PDEs and then, when I solve it with <code>BS3</code>, can confirm that Julia compiles a bunch of GPU kernels and solves it using this method fully on the GPU. Many of the more intense methods like Rosenbrock will also work on the GPU is an appropriate linear solver is given. Yes, you&#39;re reading that right: Julia is building and compiling high order stiff solvers on the GPU for us just by having the user pass in a GPUArray as the initial condition. It&#39;s pretty beautiful and will be tied into our PDE story in a bit.</p> <h2 id=dynamical_ode_problems ><a href="#dynamical_ode_problems" class=header-anchor >Dynamical ODE Problems</a></h2> <p>With the release of the symplectic methods last time, many people got excited about solving second order ODEs. However, the interface was in a woeful &quot;developer state&quot;. That changed this time around. Now we have simple problem constructors like <code>SecondOrderODEProblem</code> in a revamped documentation page to make these specialized solvers just as accessible as the standard ODE solvers.</p> <h2 id=runge-kutta_nystrom_methods ><a href="#runge-kutta_nystrom_methods" class=header-anchor >Runge-Kutta Nystrom Methods</a></h2> <p>Runge-Kutta Nystrom methods are methods which are efficient for 2nd order ODEs. They are not symplectic, but make up for that fact by being extremely efficient. We have included some 4th and 5th order methods, along with some two-step Runge-Kutta Nystrom methods which improve the efficiency by using one point in the history vector. We will be adding 6th order &#40;with dense output&#41; and 12th order methods shortly. For 2nd order ODEs, this should be much more efficient than transforming to 1st order ODEs.</p> <h2 id=dae_compatibility_with_rosenbrock_methods ><a href="#dae_compatibility_with_rosenbrock_methods" class=header-anchor >DAE Compatibility with Rosenbrock Methods</a></h2> <p>The Rosenbrock methods finished their development with tests of the ability to handle mass matrices. While these can only handle constant mass matrices, these methods are now 3/4/5 order stiffly accurate and can solve DAEs. Being fully Julia defined, they can handle things like arbitrary precision &#40;and recompile onto the GPU&#33;&#41; which make them unique in the class of efficient methods for DAEs. The DAE solver page was revamped to acknowledge these new capabilities.</p> <h2 id=muladdmacrojl ><a href="#muladdmacrojl" class=header-anchor >MuladdMacro.jl</a></h2> <p>MuladdMacro.jl is a new library that exports the <code>@muladd</code> macro. This has been heavily used internally in JuliaDiffEq because it takes expressions like <code>a &#61; b*c &#43; d*e &#43; f*g</code> and converts that into nested FMA expressions so that it&#39;s highly efficient and more robust to floating point errors. This functionality has been refactored out to an independent library for everyone else to use. Enjoy&#33;</p> <h2 id=major_improvements_to_delaydiffeqjl ><a href="#major_improvements_to_delaydiffeqjl" class=header-anchor >Major Improvements to DelayDiffEq.jl</a></h2> <p>Oh boy, a lot of improvements to the internals of DelayDiffEq.jl occured. There should be some performance improvements, but actually these changes will mostly lead to a very awesome next release. That said, we do have some things related to delay differential equations to note in this release. The new <code>OrwenZen</code> Runge-Kutta methods are &quot;continuous optimized&quot;, meaning their interpolation error is optimally low. Tests against the other Runge-Kutta methods show that these methods do great on delay differential equations. DelayDiffEq.jl now respects the vast majority of the common interface, so <code>saveat</code> and other commands work correctly &#40;even though it needs full density for the delay equation solver, it works this all out internally&#41;. This means that it can be used with parameter estimation and other addon routines.</p> <p>In addition, <code>RK4</code> added residual error adaptivity which bounds the error over the stepping interval. When used directly on a DDE, this is equivalent to the MATLAB <code>ddesd</code> delay differential equation solver. Thus technically, we have state-dependent delay equation solvers now&#33; We will be fleshing out this interface, better testing it, and adding options to make it more robust, but feel free to abuse the interface to make this work if needed.</p> <h2 id=hamiltonianproblems ><a href="#hamiltonianproblems" class=header-anchor >HamiltonianProblems</a></h2> <p>In DiffEqPhysics.jl we have new functionality which allows one to define a Hamiltonian and have that automatically create the equations of motion. Coming soon is similar capabilities for defining N-body problems from potential fields.</p> <h2 id=ddebdf_and_ddeabm ><a href="#ddebdf_and_ddeabm" class=header-anchor >ddebdf and ddeabm</a></h2> <p>New methods from ODEInterface.jl have been wrapped. These are the Shampine Adams and BDF methods. Give them a try&#33;</p> <h1 id=near_future ><a href="#near_future" class=header-anchor >Near Future</a></h1> <p>With Google Summer of Code coming to a close next month, we will be releasing a lot of the results. Here&#39;s some things you can expect soon.</p> <h2 id=waiting_to_be_released ><a href="#waiting_to_be_released" class=header-anchor >Waiting to be released</a></h2> <p>We have a ton of stuff which is actually &quot;done&quot;, but just needs some user interface touchups and documentation. These are:</p> <h3 id=iif_low_order_exponential_rk_methods ><a href="#iif_low_order_exponential_rk_methods" class=header-anchor >IIF, low order Exponential RK methods</a></h3> <p>Exponential RK methods are another class of solvers for stiff ODEs, especially those which arise from parabolic PDEs. These are implemented using the new DiffEqOperator interface, but will get some touchups before the final release.</p> <h3 id=shooting_method_and_mirk4_bvp_solvers ><a href="#shooting_method_and_mirk4_bvp_solvers" class=header-anchor >Shooting Method and MIRK4 BVP Solvers</a></h3> <p>We have BVP solvers&#33; They work. We will continue to improve them, like adding adaptivity and sparse Jacobian support. However, these will quite soon get documented and released.</p> <h3 id=lazy_finite_difference_operators ><a href="#lazy_finite_difference_operators" class=header-anchor >Lazy Finite Difference Operators</a></h3> <p>This is essentially done. Once again, touchups, docs and its released.</p> <h2 id=in_development ><a href="#in_development" class=header-anchor >In Development</a></h2> <h3 id=imex_methods ><a href="#imex_methods" class=header-anchor >IMEX Methods</a></h3> <p>IMEX methods allow you to solve stiff equations much faster by allowing you to specify part of the equation as nonstiff. Many of the SDIRK methods that were implemented have embeddings which allow for this kind of IMEX solving. Along with some new methods, our next release should allow you to have the IMEX capabilities of Sundials&#39; ARKODE solvers. These should be very good new methods for PDEs.</p> <h3 id=native_julia_radau ><a href="#native_julia_radau" class=header-anchor >Native Julia Radau</a></h3> <p>As noted above, there is still one spot where we cannot beat <code>radau</code>: high accuracy stiff ODE / DAE solving. That&#39;s why I am hoping in our next release to have a native Julia version of &#40;adaptive order&#41; Radau IIA methods. Hopefully, like we have seen with the other methods, we will be able to use Julia tricks to be best in class in performance here while adding genericness, which would be nice because a Radau method with arbitrary precision support would be a fantastic method for high accuracy DAE solving. This is high on the priority list.</p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>