<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> Stiff SDE and DDE Solvers </title> <header> <h1><b><center>SciML Open Source Scientific Machine Learning</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>﻿</p> <p>The end of the summer cycle means that many things, including Google Summer of Code projects, are being released. A large part of the current focus has been to develop tools to make solving PDEs easier, and also creating efficient tools for generalized stiff differential equations. I think we can claim to be one of the first libraries to include methods for stiff SDEs, one of the first for stiff DDEs, and one of the first to include higher order adaptive Runge-Kutta Nystrom schemes. And that&#39;s not even looking at a lot of the more unique stuff in this release. Take a look.</p> <h2 id=solvers_for_stiff_stochastic_differential_equations_sdes_and_sdaes ><a href="#solvers_for_stiff_stochastic_differential_equations_sdes_and_sdaes">Solvers for Stiff Stochastic Differential Equations &#40;SDEs and SDAEs&#41;</a></h2> <p>Stiff stochastic differential equations are a very difficult problem. Using the tooling built for ODEs we were able to build efficient drift-implicit low order methods. These use the same Jacobian-reusage quasi-Newton handling as the ODEs so the same efficiency carried over. This is only the start of a more encompassing research project on my end, but there is a theta method which implements a drift L-stable Implicit Euler-Maruyama, a drift-implicit Trapezoid and drift-implicit midpoint method. Each of these also have appropriate Milstein correction versions to be strong order 1.0 when the noise is diagonal or commutative &#40;commutative noise addressed later&#41;. Higher order and adaptive methods coming soon.</p> <h2 id=solvers_for_stiff_delay_differential_equations_ddes_and_dades ><a href="#solvers_for_stiff_delay_differential_equations_ddes_and_dades">Solvers for Stiff Delay Differential Equations &#40;DDEs and DADEs&#41;</a></h2> <p>The stiff methods from OrdinaryDiffEq.jl are now compatible with the delay equation methods. But there&#39;s more to it than that. Technically a stiff solver &#40;with mass matrices for a differential-algebraic equation&#41; in <code>MethodOfSteps</code> just works but it wasn&#39;t fully efficient. The issue is that the stiff methods weren&#39;t aware of the possibility of repetitions. Delay differential equations have to extrapolate and use fixed-point iteration in order to take timesteps larger than the smallest delay. The ODE methods which DelayDiffEq.jl wraps are now aware of this and will reuse the factorized Jacobians when steps are repeated. The result is that <code>MethodOfSteps</code> extensions of many of the Rosenbrock and SDIRK methods become very efficient solvers for stiff DDEs. More work will come by improving the fixed-point iteration scheme &#40;making it Anderson accelerated for speed and better convergence properties&#41;, but the basics are here and ready to be used.</p> <h2 id=state-dependent_delay_equation_solvers ><a href="#state-dependent_delay_equation_solvers">State-Dependent Delay Equation Solvers</a></h2> <p>State-dependent delay equations are delay differential equations where the delays are dependent on the independent and dependent variables. For example, it could be a differential equation where <code>u&#39; &#61; u&#40;t-u^2&#41;</code>. We now have two means to solve such problems.</p> <p>One is through a residual control on <code>RK4&#40;&#41;</code>. This setup is now found in the docs and is tested, and it is similar to the <code>ddesd</code> algorithm of MATLAB. While it will only solve state-dependent delay equations with low accuracy, this method is sufficient for roughly solving the equations &quot;to plotting accuracy&quot; and can be a relatively cheap means for doing so. We hope to add more residual control RK methods to fill this out.</p> <p>Additionally, we have added full discontinuity tracking for state-dependent delays. This automatically detects all discontinuities from the user-specified delays and will accurately hit these points &quot;exactly&quot;. We have verified on test equations that this indeed gets to floating point accuracy and thus should be used in cases where accuracy is needed. Additionally, this form can handle &quot;neutral&quot;. What this means is that in your history function you can use <code>h&#40;t-τ,Val&#123;1&#125;&#41;</code> to get not the value in the past, but the derivative in the past &#40;the number of derivatives you can get is dependent on the interpolant&#41;. Using order tracking for the discontinuities we can properly prorogate issues arriving from this type of interaction as well, which means that the full power of the interpolation is allowed if you set <code>neutral&#61;true</code> in the problem type. You can use this to implement things like integral equations using the history function.</p> <h2 id=boundary_value_problem_bvp_solvers ><a href="#boundary_value_problem_bvp_solvers">Boundary Value Problem &#40;BVP&#41; Solvers</a></h2> <p>BVPs are ODEs where you specify boundary constraints like &quot;u at the end must be 5&quot;. We are now releasing BoundaryValueDiffEq.jl which includes methods for solving such equations. Currently we have a <code>Shooting</code> scheme which utilizes any of the common interface IVP solvers to be an efficient method for BVPs which are not sensitive to the boundary conditions, along with a <code>GeneralMIRK4</code> scheme which uses a fully implicit Runge-Kutta method with trust region Newton solvers to be a robust method for small systems and sufficiently large timesteps, and a <code>MIRK4</code> scheme which is built to utilize sparse Jacobians for handling large BVPs with smaller timesteps efficiently. Note that <code>Shooting</code> and <code>GeneralMIRK4</code> can also handle a more general form of multi-point BVPs. For example, they can specify conditions on interior points, and <code>Shooting</code> actually has access to the full solution type which means that &quot;boundary values&quot; can be things like &quot;the maximum of the equation over the whole interval must be 5&quot;. <code>MIRK4</code> is specifically for two-point boundary value problems, and will soon include adaptivity like the MATLAB method <code>bvp4c</code>.</p> <h2 id=higher_order_methods_for_stratonovich_equations ><a href="#higher_order_methods_for_stratonovich_equations">Higher order methods for Stratonovich Equations</a></h2> <p>Milstein methods now have the option for <code>interpretation&#61;:Stratonovich</code> which will make them solve the Stratonovich form of the SDE instead of the Ito form. This means that there are many strong order 1.0 methods for Stratonovich equations now &#40;including stiff solvers&#41;.</p> <h2 id=commutative_noise_handling_in_milstein ><a href="#commutative_noise_handling_in_milstein">Commutative Noise Handling in Milstein</a></h2> <p>The new Milstein method <code>RKMilCommute</code>, is a strong order 1.0 method for both Ito and Stratonovich &#40;through the <code>interpretation</code> argument&#41; SDEs with a special form of non-diagonal noise. This is a very efficient form of non-diagonal noise which shows up in many real-world models. A full non-diagonal Milstein method is coming soon, but it will not be able to reach the efficiency of this special form. See the documentation for details on the commutative noise requirement.</p> <h2 id=domain_callbacks ><a href="#domain_callbacks">Domain Callbacks</a></h2> <p>The callback library has added some new callbacks. One of the more interesting ones are the domain callbacks which use interpolations and extrapolations to help the solvers efficiency preserve domain constraints like positivity of the dependent variable. Check out the docs for details. <code>isoutofdomain</code> will remain the standard since it doesn&#39;t require any regularity outside of the domain, but this new version is blazing fast when applicable so please check it out&#33;</p> <h2 id=higher_order_dense_and_adaptive_runge-kutta_nystrom_solvers ><a href="#higher_order_dense_and_adaptive_runge-kutta_nystrom_solvers">Higher Order Dense and Adaptive Runge-Kutta Nystrom Solvers</a></h2> <p>Symplectic methods preserve energy when solving 2nd order ODEs. What if you don&#39;t need long-time preservation and just want accuracy? That&#39;s where Runge-Kutta Nystrom methods come in. Last time we released the first few, but they were low order methods. Now we have all of the big guns. 6th order adaptive method with 6th order interpolation, 8th order adaptive method, 12th order adaptive method, two-step methods, etc. See the Dynamical ODE Solvers docs for more details. These should be more efficient than using first order ODE solvers on transformed second order ODEs.</p> <h2 id=exponential_integrators ><a href="#exponential_integrators">Exponential Integrators</a></h2> <p>They are finally here. Only low order exponential Runge-Kutta and Implicit Integrating Factor &#40;IIF&#41; methods, but they and their machinery now exist and are released. They require that the problem be specified as a <code>SplitODEProblem</code> where the first part is a linear operator, and it will use the linear operator directly in order to exactly integrate that part. This is good for discretizations of semilinear PDEs. We will be continuing to improve this area over the coming year.</p> <p>Right now the existing methods are made for problems where the system is small enough that the dense <code>exp&#40;dt*A&#41;</code> can be created and cached. For large PDEs we will need an efficient <code>expmv&#33;</code> method. These will be created and released as separate versions of these algorithms &#40;ex: <code>IIF2</code> vs <code>IIF2Krylov</code>&#41;. However, this is currently blocked because we need to implement the <code>expmv&#33;</code> algorithms which is the subject of a new project in development.</p> <h2 id=new_tooling_package_diffeqdifftoolsjl ><a href="#new_tooling_package_diffeqdifftoolsjl">New Tooling Package: DiffEqDiffTools.jl</a></h2> <p>During a bunch of benchmarking members of JuliaDiffEq &#40;@dextorious&#41; noticed that Calculus.jl is not suitable for our Jacobian needs. This member created finite differencing methods which are efficient for the kinds of equations found in JuliaDiffEq, giving an almost 100x speedup over the previous finite differencing method. Although this only serves as the fallback when <code>autodiff&#61;false</code>, these methods will be a major win for our stiff solvers. Included is also complex-mode finite differentiation which is able to numerically differentiate at almost machine epsilon accuracy like autodifferentiation, giving not only efficient but also accurate fallbacks when autodifferentiation is not appropriate. These methods can directly handle things like <code>BandedMatrix</code> from BandedMatrices.jl and GPUArrays, meaning that they will form the backbone of our coming sparse Jacobian support. In addition, these methods should soon support building Jacobians for problems defined with complex numbers, fixing the problem we&#39;ve had that no stiff solvers work without analytical Jacobians on problems with complex numbers since ForwardDiff.jl does not support them.</p> <h2 id=fenicsjl ><a href="#fenicsjl">FEniCS.jl</a></h2> <p>With this release we are also releasing a wrapper to the FEniCS finite element library. While there is still a lot more to do, the current wrapper gives you the tools to run the basic FEniCS tutorials using pure Julia code, and allows you to extract the assembled matrices in order to use them in further computations in Julia. This is just the start of a more comprehensive finite element support via FEniCS wrappers, and we hope to build some PDE solver tools which make use of this.</p> <h2 id=lazy_derivative_operators_diffeqoperatorsjl ><a href="#lazy_derivative_operators_diffeqoperatorsjl">Lazy Derivative Operators: DiffEqOperators.jl</a></h2> <p>Take a PDE. Look at the derivatives it has. Say &quot;I want the discretized finite difference operators for those derivatives, and make them 4th order&quot;. Get back linear operators and define the ODE from those. That&#39;s a standard approach for solving partial differentiation equations, but in many cases this get can be tedious since handling boundary conditions and finding out the higher order discretization is not easy.</p> <p>DiffEqOperators.jl&#39;s derivative operators do just this. You ask for the 4th order discretization of the 4th derivative, and it spits back a matrix-free linear operator that performs that calculation upon multiplication, and does so in a multithreaded way &#40;and has non-allocating dispatches&#41;. You can even use this to easily build banded, sparse, and dense matrices corresponding to the discretized operators making it easy to blend new tooling with older methods. In addition, this includes matrix-free implementations of operators for the upwind schemes. This makes it easy to implement 4th order upwind schemes for hyperbolic PDEs without having to derive the full discretization, and these operators, being matrix-free, are able to update their directions each step efficiently. These operators all allow for specifying time-dependent boundary conditions and can be used with tooling like IterativeSolvers.jl. This makes finite difference discretizations a breeze.</p> <h2 id=ssp_limiters ><a href="#ssp_limiters">SSP Limiters</a></h2> <p>In addition to adding many more strong-stability preserving methods, these methods now have the possibility for the user to pass in a <code>limiter</code> function to ensure that properties like positivity are preserved at each step of the integrator. Needless to say, this is very helpful for solving hyperbolic PDEs with larger timesteps. In addition we now document the SSP coefficients so users can more easily set maximal timesteps to match what&#39;s necessary via the CFL constraints.</p> <h1 id=in_development ><a href="#in_development">In Development</a></h1> <p>Note that some projects have been sectioned off as <a href="https://sciml.ai/soc/projects/diffeq.html">possible GSoC projects</a>. These would also do well as new contributor projects if anyone&#39;s interested, and so these are not considered in the &quot;in development&quot; list as we are leaving these open for newcomers/students.</p> <p>Putting those aside, this is the main current &quot;in development&quot; list:</p> <ul> <li><p>IMEX Methods</p> <li><p>Methods for efficient <code>expmv&#33;</code></p> <li><p>Native Julia Radau</p> <li><p>Anderson acceleration of unconstrained DDE steps</p> <li><p>Improved jump methods &#40;tau-leaping&#41;</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>