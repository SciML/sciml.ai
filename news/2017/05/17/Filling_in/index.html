<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> Filling In The Interop Packages and Rosenbrock </title> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>In the <a href="https://www.stochasticlifestyle.com/differentialequations-jl-2-0-state-ecosystem/">2.0 state of the ecosystem post</a> it was noted that, now that we have a clearly laid out and expansive common API, the next goal is to fill it in. This set of releases tackles the lowest hanging fruits in that battle. Specifically, the interop packages were setup to be as complete in their interfaces as possible, and the existing methods which could expand were expanded. Time for specifics.</p> <h3 id=revamped_ode_and_sde_tutorials ><a href="#revamped_ode_and_sde_tutorials">Revamped ODE and SDE Tutorials</a></h3> <p>All of the docs have been undergoing a pretty thorough review to make sure that every feature is documented. But the tutorials are there to give a simple introduction. After having many different users provide feedback, we have revamped the ODE and SDE tutorials to more effectively drive users to writing clear and efficient code. If there are any concerns, please open and issue or come chat in the Gitter chatroom. Docs can always be improved&#33;</p> <h3 id=odeinterfacediffeq_jacobians_and_mass_matrices ><a href="#odeinterfacediffeq_jacobians_and_mass_matrices">ODEInterfaceDiffEq: Jacobians and Mass Matrices</a></h3> <p>ODEInterfaceDiffEq.jl is a great interop package with its <code>radau</code> being a very fast stiff solver. Now the JuliaDiffEq way of defining the Jacobian and mass matrix is used by this package to speed up your calculations even more.</p> <h3 id=interpolations_all_around_hermites_and_linear ><a href="#interpolations_all_around_hermites_and_linear">Interpolations All Around: Hermites and Linear</a></h3> <p>This is a big update. For the packages which had no interpolations before yet had a cheap way to save the derivative &#40;Sundials and DASKR&#41;, a free Hermite interpolation was added. This gives these packages a 3rd Order interpolation without extra work.</p> <p>For all packages which do not have interpolations, and anytime <code>dense&#61;false</code> on a package with interpolations, it now happens that the solution object still has an interpolation. The solution object is outfitted with a fallback to a linear interpolation in this case, since this requires no information other than the values at the two time points and the locations in time. This means that every solution can be interpolated, though in some cases &#40;ODE.jl, ODEInterface.jl, LSODA.jl, and <code>dense&#61;false</code>. Note <code>dense&#61;false</code> occurs when <code>saveat</code> is set by default, but can be flipped on as needed&#41; the interpolation is only 1st order &#40;linear&#41;. Still, this makes it easy for the user to make the choice in a pinch.</p> <p>But 3rd order interpolations on Sundials and DASKR is a big win. Since these normally fluctuate between order 2-4, this almost has the same order as the solution time points itself, and thus is a very reliable result.</p> <h3 id=derivative_interpolation ><a href="#derivative_interpolation">Derivative Interpolation</a></h3> <p>For the methods of OrdinaryDiffEq.jl, <code>Val&#123;1&#125;</code> in the interpolant now makes it return the interpolant derivative. Since these are hardcoded directly from the interpolation coefficients, these are fast calculations which avoid the standard numerical issues of finite differencing. In addition, linear interpolations now will return the constant derivative estimate in the interval, and Hermite interpolations have both the 1st, 2nd, and 3rd derivative estimates. Other derivatives will keep being added, and the interpolants will get derivatives up to the order of interpolation in the future. It&#39;s not difficult, but it&#39;s tedious work, so thank @gabrielgellner&#33;</p> <h3 id=default_algorithm_updates ><a href="#default_algorithm_updates">Default Algorithm Updates</a></h3> <p>A major update which is slightly hidden to users is a re-work of the default algorithms. The default algorithm choices underwent a major update, and now things like ODE solver choices are much more sophisticated, taking into account the existence of callbacks and mass matrices, the user&#39;s tolerance levels, etc. This should improve the &quot;automatic&quot; experience of DifferentialEquations.jl.</p> <h3 id=warnings_on_incompatibility ><a href="#warnings_on_incompatibility">Warnings on Incompatibility</a></h3> <p>One huge ecosystem update is that, now that everything is pretty much set, we decided to warn users when interface options are ignored. For example, Sundials cannot use the advanced adaptive <code>beta1</code> argument. So if you use a Sundials algorithm and set this option, it will give you a warning. The setup is: <code>warn</code> when the solution will still be true but something is ignored, but error when it&#39;s false. So if an algorithm doesn&#39;t support mass matrices, solving it by ignoring mass matrices would be solving the wrong equation, and thus it <code>error</code>s in this case.</p> <p>In addition, if you are using a method for stiff equations, explicitly set a Jacobian/t-gradient, and the solver cannot use this Jacobian/t-gradient, then you will receive a warning that your Jacobian/t-gradient overload was ignored. This should help users better orient themselves to what is interface-compatible. In addition, this warning leads users to the <a href="https://docs.juliadiffeq.org/latest/basics/compatibility_chart">compatibility chart</a>.</p> <p>In any case, these warnings can be turned off by setting <code>verbose&#61;false</code>. We hope that these warnings help you know in advance what options have a real effect on each and every solver method.</p> <h3 id=monte_carlo_analysis_tools ><a href="#monte_carlo_analysis_tools">Monte Carlo Analysis Tools</a></h3> <p>The result of many user requests, there now exists a full suite of analysis tools for analyzing the results of your Monte Carlo experiments. <a href="https://docs.juliadiffeq.org/latest/features/monte_carlo">The improved docs</a> detail how to use the functionality for getting means, medians, variances, covariances, etc. and plotting the timeseries of these values.</p> <h3 id=comprehensive_noise_processes ><a href="#comprehensive_noise_processes">Comprehensive Noise Processes</a></h3> <p>Noise processes reached their pinnacle design state&#33; If you&#39;re interested in noise processes, you <a href="https://docs.juliadiffeq.org/latest/features/noise_process">should check out the very comprehensive docs</a>. The big parts of the change are the following. Noise processes can form their own problems now, and so these can be solved just like any other diffeq, even with Monte Carlo tools. This is great because the standard noise processes are are not SDE approximations and are thus distributionally-exact. Therefore if you need very exact properties of say <code>GeometricBrownianMotion</code>, you can use this noise process to generate it without any SDE solving, making it high performance without the numerical approximation error. In addition, as just noted, many basic noise processes like <code>BrownianBridge</code> and <code>OrnsteinUhlenbeck</code> have this distributionally-exact implementation.</p> <p>But even better &#40;for developers&#41;, this form of <code>NoiseProcess</code> is now just one of many <code>AbstractNoiseProcess</code> types. The others can be used to build high-fidelity &#40;though not distributionally-exact&#41; noise processes through common means. For example, <code>NoiseGrid</code> lets you build an <code>AbstractNoiseProcess</code> from a grid of points. This means that your standard way of generating temporally-correlated noise &#40;building an array&#41; is compatible with the JuliaDiffEq interface, and you can use this noise array directly in the SDE solvers. Additionally, <code>NoiseApproximation</code> lets you define processes from other SDEs, letting you implant SDE solutions as the <code>dW</code> in another SDE.</p> <p>If this is not your mathematical forte but you are still interested in using noise processes, this part of the update is still huge because these will be the tools that will be used to build standard versions of more complex noise processes. For example, <code>PinkNoise</code> and <code>FractionalBrownianMotion</code> can be easily built using a <code>NoiseGrid</code>, and thus in the near future we will offer direct constructors for these noise types to be used in the SDE/RODE solvers to make modeling with colored noise very accessible. What is really nice is that all of these <code>AbstractNoiseProcess</code> types build appropriate back-interpolations, meaning that adaptive timestepping methods can be compatible with them &#40;given a suitable error estimate&#41;.</p> <h3 id=full_precompilation ><a href="#full_precompilation">Full Precompilation</a></h3> <p>This update follows an update in SymEngine.jl that lets it use libsymengine v0.3.0. This means that ParameterizedFunctions.jl could get rid of all uses of <code>@eval</code> and finally precompile. The result is that every package in JuliaDiffEq is now precompilation-safe &#40;before, ParameterizedFunctions.jl and DifferentialEquations.jl had precompilation turned off for this reason&#41;.</p> <h3 id=improved_derivative_information_in_the_ode_def_macro ><a href="#improved_derivative_information_in_the_ode_def_macro">Improved Derivative Information in the <code>@ode_def</code> Macro</a></h3> <p>The SymEngine change had one additional benefit. A wider range of equations can now be symbolically differentiated. This means that your equations can have special functions like <code>erf</code> and now receive a symbolically-calculated Jacobian. This should help sufficiently weird equations run faster with stiff solvers&#33;</p> <h3 id=rosenbrock_to_the_limits ><a href="#rosenbrock_to_the_limits">Rosenbrock: To the Limits</a></h3> <p>The <code>Rosenbrock23</code> and <code>Rosenbrock32</code> methods now support the full the limits of the common interface. Before they could do all of the event things like resize, but they did not support all of the performance enhancements. Now the <code>Rosenbrock</code> methods will directly use the <code>invW</code> equations from the <code>@ode_def</code> macro to be explicit stiff solvers in these cases. It includes fallbacks to using the Jacobian and t-gradient for cases where that is not defined, and has a fallback to autodifferentiation and numerical differentition if nothing else is defined. These methods now support mass matrices as well. This means that these methods, being A-B-L stable, are an &quot;everyman&#39;s method&quot;: they can do anything, and can get any of the performance boosts that are possible. We will be working on higher order versions, but even when those are created, <code>Rosenbrock23</code> should be considered a foundational stiff method because of its impeccable stability &#40;no higher order method, has all of these stability properties. Not even BDF methods like Sundials&#33;&#41;, and so it&#39;s good that this method is essentially complete &#40;barring bugfixes&#41;.</p> <h3 id=improved_dedataarray ><a href="#improved_dedataarray">Improved DEDataArray</a></h3> <p>Now when interpolating <code>DEDataArray</code>, its non <code>.x</code> values hold true to their discrete interpolation and are considered constant on any interval of integration. Thus interpolating a <code>DEDataArray</code> will keep the same non <code>.x</code> values as the left-hand side of the integration.</p> <p>In addition, using <code>DEDataArray</code> is now compatible with &quot;in-equation updates&quot;. <a href="https://docs.juliadiffeq.org/latest/features/diffeq_arrays">The docs now show</a> that DEDataArrays can be updated by updating the <code>u</code> variable in the equation &#40;keeping with the theme &quot;discrete&quot;, and thus <code>du</code> does not record changes to these variables&#41;. These changed values will then be saved for the next iteration, and are saved in the final result. This allows you to easily mix in discrete variables, or save the results of algebraic relations between other variables. Some solvers are not compatible with this usage, and this is now explicitly stated with the solver choice.</p> <h3 id=pydstool_removed_from_differentialequations ><a href="#pydstool_removed_from_differentialequations">PyDSTool Removed From DifferentialEquations</a></h3> <p>PyDSTool is an addon which is only used for bifurcation plotting, so it was too large to justify having by default. It&#39;s kept in the documentation, and instead the relevant documentation page tells the user to install this package before using.</p> <h3 id=io_functionality ><a href="#io_functionality">IO Functionality</a></h3> <p>IO is now out of its experimental phase into its early release. It&#39;s still being worked on, but <a href="https://docs.juliadiffeq.org/latest/features/io">the documentation page exists</a>.</p> <h3 id=monte_carlo_reductions ><a href="#monte_carlo_reductions">Monte Carlo Reductions</a></h3> <p>Monte Carlo reductions allow you to solve the parallel problem in batches, and perform operations on the batches. Thus, instead of building a big array of the solutions, you can instead in batches of 200 take the mean at each timeseries, and add it to the mean of the last batch&#40;es&#41;. This way, no more than 200&#43;1 timeseries ever have to be in memory, drastically reducing the memory cost and still outputting the desired quantity. In addition, convergence checks can be done at the batch calculations. For example, you can check the standard error of the mean &#40;SEM&#41;, and have the Monte Carlo simulation stop when the SEM is low enough &#40;indicating that you&#39;ve ran enough samples to get the confidence in the mean sufficiently small&#41;. This can save a lot time by adaptiving the simulation size as necessary.</p> <h3 id=support_for_staticarrays ><a href="#support_for_staticarrays">Support for StaticArrays</a></h3> <p>StaticArrays.jl provides static and fixed-sized arrays that speed up computations on small systems. The <code>*DiffEq</code> methods now fully support using <code>SArray</code> and <code>MArray</code> types. The <code>SArray</code> types are stack-allocated, meaning that the not-in-place versions can be used on these arrays without a performance penalty &#40;in fact, they can have a large performance gain&#33;&#41;. <code>MArray</code>s can be used in place of normal arrays when you know the size is constant, and speedups can occur due to extra compiler optimizations. Together, these are a good set of types for many use cases.</p> <h2 id=minor_changes ><a href="#minor_changes">Minor Changes</a></h2> <ul> <li><p>Improved Monte Carlo pmap speed via an extra caching step</p> <li><p>Fixed some interpolation bugs when differentiating by ForwardDiff</p> <li><p>Fixed a <code>NoiseWrapper</code> bug when interpolating many times in the same interval</p> <li><p>Added an error to <code>add_tstop&#33;</code> when the added time lags behind the current time</p> <li><p>Fixed <code>plot_analytic</code> for refined problems</p> <li><p>Added a recursive dispatch to the default norm for handling nested arrays</p> <li><p><code>L2DistLoss</code> added to DiffEqParamEstim.jl for improved efficiency</p> <li><p>Improved numerical accuracy in interpolations &#40;Horner&#39;s rule&#41;</p> <li><p>Greatly improved OrdinaryDiffEq and DiffEqNoiseProcess tests</p> </ul> <h2 id=near_future ><a href="#near_future">Near Future</a></h2> <p>In the next minor release, I am hoping to accomplish the following:</p> <h3 id=iif_methods_for_split_linear-nonlinear_equations_and_low_order_exponential_runge-kutta_methods ><a href="#iif_methods_for_split_linear-nonlinear_equations_and_low_order_exponential_runge-kutta_methods">IIF Methods for Split Linear-Nonlinear Equations and Low Order Exponential Runge-Kutta Methods</a></h3> <p>An implementation of these actually exist now, and pass convergence tests. Caching of the exponential and setup with ExpoKit.jl or ExpmV.jl will be necessary before this is ready for prime-time.</p> <h3 id=high_order_rosenbrock_methods ><a href="#high_order_rosenbrock_methods">High Order Rosenbrock Methods</a></h3> <p>The coefficients are in, but these need to be debugged.</p> <h3 id=velocity_verlets ><a href="#velocity_verlets">Velocity Verlets</a></h3> <p>This is not far off.</p> <h3 id=shooting_method_bvp_solver ><a href="#shooting_method_bvp_solver">Shooting Method BVP Solver</a></h3> <p>It&#39;s already created and robust. We just need to clarify the problem setup, add some documentation, and get things registered.</p> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>