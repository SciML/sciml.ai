<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title> DifferentialEquations.jl v6.12.0: DAE Extravaganza </title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://docs.sciml.ai/SciMLBenchmarksOutput/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=differentialequationsjl_v6120_dae_extravaganza ><a href="#differentialequationsjl_v6120_dae_extravaganza" class=header-anchor >DifferentialEquations.jl v6.12.0: DAE Extravaganza</a></h1> <p>This release is the long-awaited DAE extravaganza&#33; We are releasing fully-implicit DAE integrators written in pure Julia, and thus compatible with items things like GPUs and arbitrary precision. We have various DAE initialization schemes to allow for automatically finding consistent initial conditions, and have also upgraded our solvers to solve state and time dependent mass matrices. These results have also trickled over to DiffEqFlux, with the new neural ODE structs which support singular mass matrices &#40;DAEs&#41;. Together this is a very comprehensive push into the DAE world.</p> <h2 id=dimpliciteuler_and_dbdf2_fully_implicit_dae_solvers_in_pure_julia ><a href="#dimpliciteuler_and_dbdf2_fully_implicit_dae_solvers_in_pure_julia" class=header-anchor >DImplicitEuler and DBDF2: Fully Implicit DAE Solvers in Pure Julia</a></h2> <p>Yes, you saw that correctly. There is now a fully implicit DAE solver setup in pure Julia, meaning that high performance, GPU, arbitrary precision, uncertainty quantification, automatic differentiation, etc. all exist on a set of fully implicit ODEs. All of the standard features, like callback support and linear solver choices, also apply. Currently we only offer the first and second order BDF methods, but this is the difficult part and fully implicit DAE adaptive order BDF is coming soon, likely this summer. This checks off one of the longest standing requests for the JuliaDiffEq ecosystem. Thank Kanav Gupta &#40;@kanav99&#41; for this wonderful addition.</p> <p><a href="https://docs.juliadiffeq.org/latest/solvers/dae_solve/">The documentation for DAE solvers has been redone, so please check it out&#33;</a></p> <h2 id=dae_initialization_choices ><a href="#dae_initialization_choices" class=header-anchor >DAE Initialization Choices</a></h2> <p>Along with the new DAE solvers, there&#39;s now a setup for initialization algorithms for finding consistent initial conditions. These work on semi-explicit mass matrix ODEs &#40;i.e. singular mass matrices&#41; and fully implicit ODEs in <code>f&#40;u&#39;,u,p,t&#41;&#61;0</code> form. A dispatch system on initialization algorithms was created so we can iteratively keep enhancing the system, and we currently have implemented the method from Brown &#40;i.e. DASSL&#41; for initializing only the algebraic part, and a collocation method from Shampine that initializes both the differential and algebraic equations. Again, we will continue to iteratively add to this selection over time. A large part of this is due to Kanav Gupta &#40;@kanav99&#41;.</p> <h2 id=state_and_time_dependent_mass_matrices_ie_muptufupt ><a href="#state_and_time_dependent_mass_matrices_ie_muptufupt" class=header-anchor >State and time dependent mass matrices, i.e. M&#40;u,p,t&#41;u&#39;&#61;f&#40;u,p,t&#41;</a></h2> <p>Mass matrices can now be made state and time dependent using DiffEqOperators. For example, the following is a valid mass matrix system:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> f(du,u,p,t)
    du[<span class=hljs-number >1</span>] = u[<span class=hljs-number >1</span>]
    du[<span class=hljs-number >2</span>] = u[<span class=hljs-number >2</span>]
    du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>
<span class=hljs-keyword >function</span> update_func(A,u,p,t)
    A[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>] = cos(t)
    A[<span class=hljs-number >2</span>,<span class=hljs-number >1</span>] = sin(t)*u[<span class=hljs-number >1</span>]
    A[<span class=hljs-number >3</span>,<span class=hljs-number >1</span>] = t^<span class=hljs-number >2</span>
    A[<span class=hljs-number >1</span>,<span class=hljs-number >2</span>] = cos(t)*sin(t)
    A[<span class=hljs-number >2</span>,<span class=hljs-number >2</span>] = cos(t)^<span class=hljs-number >2</span> + u[<span class=hljs-number >3</span>]
    A[<span class=hljs-number >3</span>,<span class=hljs-number >2</span>] = sin(t)*u[<span class=hljs-number >2</span>]
    A[<span class=hljs-number >1</span>,<span class=hljs-number >3</span>] = sin(t)
    A[<span class=hljs-number >2</span>,<span class=hljs-number >3</span>] = t^<span class=hljs-number >2</span>
    A[<span class=hljs-number >3</span>,<span class=hljs-number >3</span>] = t*cos(t) + <span class=hljs-number >1</span>
<span class=hljs-keyword >end</span>
dependent_M1 = DiffEqArrayOperator(ones(<span class=hljs-number >3</span>,<span class=hljs-number >3</span>),update_func=update_func1)
prob = ODEProblem(ODEFunction{iip,<span class=hljs-literal >true</span>}(f, mass_matrix=mm_A), u0, tspan)</code></pre> <p>is a valid specification of a <code>M&#40;u,p,t&#41;u&#39;&#61;f&#40;u,p,t&#41;</code> system which can then be solved with methods <a href="https://docs.juliadiffeq.org/latest/solvers/dae_solve/">as described on the DAE solver page</a>. We have found that Yingbo Ma&#39;s OrdinaryDiffEq.jl RadauIIA works quite well for such systems, so do give it a try&#33;</p> <h2 id=neural_dae_structs_in_diffeqflux ><a href="#neural_dae_structs_in_diffeqflux" class=header-anchor >Neural DAE Structs in DiffEqFlux</a></h2> <p>Continuing with the DAE theme, we now have <code>NeuralODEMM</code> inside of DiffEqFlux.jl for specifying semi-explicit mass matrix ODEs in order to impose constraint equations in the time evolution of the system. For example, the following is a neural DAE where the sum of the 3 ODE variables is constrained to 1:</p> <pre><code class="julia hljs">dudt2 = FastChain(FastDense(<span class=hljs-number >3</span>,<span class=hljs-number >64</span>,tanh),FastDense(<span class=hljs-number >64</span>,<span class=hljs-number >2</span>))
ndae = NeuralODEMM(dudt2, (u,p,t) -&gt; [u[<span class=hljs-number >1</span>] + u[<span class=hljs-number >2</span>] + u[<span class=hljs-number >3</span>] - <span class=hljs-number >1</span>], tspan, M, Rodas5(autodiff=<span class=hljs-literal >false</span>),saveat=<span class=hljs-number >0.1</span>)</code></pre> <p>We are excited to see what kinds of applications people will come up with given such a tool, since properties like conservation of energy can now be directly encoded into the trained system.</p> <h2 id=mass_matrix_dae_adjoints ><a href="#mass_matrix_dae_adjoints" class=header-anchor >Mass Matrix DAE Adjoints</a></h2> <p>In conjunction with the neural ODEs with constraints provided by mass matrices, we have released new additions to the adjoint methods which allow them to support singular mass matrices. This is another great addition by Yingbo Ma &#40;@YingboMa&#41;.</p> <h2 id=massive_neural_ode_performance_improvements ><a href="#massive_neural_ode_performance_improvements" class=header-anchor >Massive Neural ODE Performance Improvements</a></h2> <p>There has been another set of massive neural ODE performance improvements. Making use of ReverseDiff.jl in strategic ways, avoiding Flux allocations, and fast-paths for common adjoints were all part of the game. We saw another 2x speedup from these advances.</p> <h2 id=second_order_sensitivity_analysis_and_sciml_train_newton_methods ><a href="#second_order_sensitivity_analysis_and_sciml_train_newton_methods" class=header-anchor >Second Order Sensitivity Analysis and sciml_train Newton Methods</a></h2> <p>Second order sensitivity analysis has been added to the DiffEqSensitivity.jl library. One can either query for fast Hessian calculations or for fast Hessian-vector products. These utilize a mixture of AD and adjoint methods for performing the computation in a time and memory efficient manner. For example, the following return the Hessian and the Hessian-vector product of the ODE system with respect to parameters:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> fb(du,u,p,t)
  du[<span class=hljs-number >1</span>] = dx = p[<span class=hljs-number >1</span>]*u[<span class=hljs-number >1</span>] - p[<span class=hljs-number >2</span>]*u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>]
  du[<span class=hljs-number >2</span>] = dy = -p[<span class=hljs-number >3</span>]*u[<span class=hljs-number >2</span>] + p[<span class=hljs-number >4</span>]*u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> jac(J,u,p,t)
  (x, y, a, b, c) = (u[<span class=hljs-number >1</span>], u[<span class=hljs-number >2</span>], p[<span class=hljs-number >1</span>], p[<span class=hljs-number >2</span>], p[<span class=hljs-number >3</span>])
  J[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>] = a + y * b * -<span class=hljs-number >1</span>
  J[<span class=hljs-number >2</span>,<span class=hljs-number >1</span>] = y
  J[<span class=hljs-number >1</span>,<span class=hljs-number >2</span>] = b * x * -<span class=hljs-number >1</span>
  J[<span class=hljs-number >2</span>,<span class=hljs-number >2</span>] = c * -<span class=hljs-number >1</span> + x
<span class=hljs-keyword >end</span>

f = ODEFunction(fb,jac=jac)
p = [<span class=hljs-number >1.5</span>,<span class=hljs-number >1.0</span>,<span class=hljs-number >3.0</span>,<span class=hljs-number >1.0</span>]; u0 = [<span class=hljs-number >1.0</span>;<span class=hljs-number >1.0</span>]
prob = ODEProblem(f,u0,(<span class=hljs-number >0.0</span>,<span class=hljs-number >10.0</span>),p)
loss(sol) = sum(sol)
v = ones(<span class=hljs-number >4</span>)

H  = second_order_sensitivities(loss,prob,Vern9(),saveat=<span class=hljs-number >0.1</span>,abstol=<span class=hljs-number >1e-12</span>,reltol=<span class=hljs-number >1e-12</span>)
Hv = second_order_sensitivity_product(loss,v,prob,Vern9(),saveat=<span class=hljs-number >0.1</span>,abstol=<span class=hljs-number >1e-12</span>,reltol=<span class=hljs-number >1e-12</span>)</code></pre> <h2 id=magnus_integrators_for_uatu_and_lie_group_integrators_for_uautu ><a href="#magnus_integrators_for_uatu_and_lie_group_integrators_for_uautu" class=header-anchor >Magnus Integrators for u&#39;&#61;A&#40;t&#41;u and Lie Group Integrators for u&#39;&#61;A&#40;u,t&#41;u</a></h2> <p>If your system is described by a time-dependent linear operator, like many PDE systems, the integration can be greatly improved by exploiting this structure of the problem. The OrdinaryDiffEq.jl now supports Magnus integrators which utilize the Krylov exponential tooling of exponential integrators in order to support large-scale time-dependent systems in a way that preserves the solution manifold. For state-dependent problems, a similar set of methods, the Lie group methods, has also been started, with the infrastructure in place and the implementation of the LieEuler method. The next step of just adding more methods is the easy part, and we expect a whole litany of methods in these two categories for the next release.</p> <h1 id=next_directions ><a href="#next_directions" class=header-anchor >Next Directions</a></h1> <p>Here&#39;s some things to look forward to:</p> <ul> <li><p>Automated matrix-free finite difference PDE operators</p> <li><p>Jacobian reuse efficiency in Rosenbrock-W methods</p> <li><p>High Strong Order Methods for Non-Commutative Noise SDEs</p> <li><p>Stochastic delay differential equations</p> </ul> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>