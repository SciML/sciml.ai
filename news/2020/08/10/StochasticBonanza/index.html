<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content=SciML > <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://www.youtube.com/playlist?list=PLP8iPy9hna6QglWLQM02jcVjEBjaamzvw">Watch the recordings of SciMLCon 2022</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-light bg-light static-top"> <div class=container > <a class="btn btn-primary" href="/" class=current >Home</a> <a class=navbar-brand  href="/news/">News</a> <a class=navbar-brand  href="/roadmap/">Roadmap</a> <a class=navbar-brand  href="/citing/">Citing</a> <a class=navbar-brand  href="/showcase/">Showcase</a> <a class=navbar-brand  href="/challenge/">Challenge Problems</a> <a class=navbar-brand  href="/community/">Community</a> <hr/> <a class=navbar-brand  href="/documentation/">Documentation</a> <a class=navbar-brand  href="/dev/">Dev Programs</a> <a class=navbar-brand  href="/governance/">Governance</a> <a class=navbar-brand  href="https://benchmarks.sciml.ai/">Benchmarks</a> <a class=navbar-brand  href="https://github.com/SciML/">Source Code</a> <a class=navbar-brand  href="https://numfocus.org/donate-to-sciml">Donate</a> </div> </nav> </header> <div class=franklin-content ><h1 id=sciml_ecosystem_update_chemical_reaction_modeling_and_major_stochastic_simulation_improvements ><a href="#sciml_ecosystem_update_chemical_reaction_modeling_and_major_stochastic_simulation_improvements" class=header-anchor >SciML Ecosystem Update: Chemical Reaction Modeling and Major Stochastic Simulation Improvements</a></h1> <p>This ecosystem update has a lot of stochastic components added. We have a new DSL and a bunch of new solvers which incorporate jump dynamics for Levy processes &#40;jump diffusions&#41;. Let&#39;s &quot;jump&quot; right in&#33;</p> <h2 id=catalystjl_chemical_reaction_models ><a href="#catalystjl_chemical_reaction_models" class=header-anchor >Catalyst.jl: Chemical Reaction Models</a></h2> <p><a href="https://catalyst.sciml.ai/dev/">Catalyst.jl</a> is our rebranding of the old DiffEqBio for its expanded role in chemical reaction modeling. You can easily design reaction networks and then simulate them with fast methods for jump equations:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Catlayst, DiffEqJump

rs = <span class=hljs-meta >@reaction_network</span> <span class=hljs-keyword >begin</span>
  c1, S + E --&gt; SE
  c2, SE --&gt; S + E
  c3, SE --&gt; P + E
<span class=hljs-keyword >end</span> c1 c2 c3
p = (<span class=hljs-number >0.00166</span>,<span class=hljs-number >0.0001</span>,<span class=hljs-number >0.1</span>)   <span class=hljs-comment ># [c1,c2,c3]</span>
tspan = (<span class=hljs-number >0.</span>, <span class=hljs-number >100.</span>)
u0 = [<span class=hljs-number >301.</span>, <span class=hljs-number >100.</span>, <span class=hljs-number >0.</span>, <span class=hljs-number >0.</span>]  <span class=hljs-comment ># [S,E,SE,P]</span>

<span class=hljs-comment ># solve JumpProblem</span>
dprob = DiscreteProblem(rs, u0, tspan, p)
jprob = JumpProblem(rs, dprob, Direct())
jsol = solve(jprob, SSAStepper())
plot(jsol,lw=<span class=hljs-number >2</span>,title=<span class=hljs-string >&quot;Gillespie: Michaelis-Menten Enzyme Kinetics&quot;</span>)</code></pre> <p><img src="https://user-images.githubusercontent.com/1814174/87864114-3bf9dd00-c932-11ea-83a0-58f38aee8bfb.png" alt="" /></p> <p>All of the current DifferentialEquations simulation features can be directly applied to Catalyst. Additionally, Catalyst is built on <a href="https://mtk.sciml.ai/dev/">ModelingToolkit.jl</a> so all of the <a href="https://youtu.be/UNkXNZZ3hSw">automatic optimization and parallelism features</a> can be directly applied to Catalyst generated code. A lot of the following features also extend continuous-time Markov models as well in new ways&#33;</p> <h2 id=adaptive_post-leap_tau_leaping ><a href="#adaptive_post-leap_tau_leaping" class=header-anchor >Adaptive Post-Leap Tau Leaping</a></h2> <p>Adaptive post-leap tau-leaping is here&#33; For example, an adaptive tau-leaping SIR can be written as:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> StochasticDiffEq, DiffEqJump, DiffEqBase, Statistics
<span class=hljs-keyword >using</span> Test, LinearAlgebra

<span class=hljs-keyword >function</span> regular_rate(out,u,p,t)
    out[<span class=hljs-number >1</span>] = (<span class=hljs-number >0.1</span>/<span class=hljs-number >1000.0</span>)*u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>]
    out[<span class=hljs-number >2</span>] = <span class=hljs-number >0.01</span>u[<span class=hljs-number >2</span>]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >const</span> dc = zeros(<span class=hljs-number >3</span>, <span class=hljs-number >2</span>)
dc[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>] = -<span class=hljs-number >1</span>
dc[<span class=hljs-number >2</span>,<span class=hljs-number >1</span>] = <span class=hljs-number >1</span>
dc[<span class=hljs-number >2</span>,<span class=hljs-number >2</span>] = -<span class=hljs-number >1</span>
dc[<span class=hljs-number >3</span>,<span class=hljs-number >2</span>] = <span class=hljs-number >1</span>

<span class=hljs-keyword >function</span> regular_c(du,u,p,t,counts,mark)
    mul!(du,dc,counts)
<span class=hljs-keyword >end</span>

rj = RegularJump(regular_rate,regular_c,<span class=hljs-number >2</span>)
jumps = JumpSet(rj)
iip_prob = DiscreteProblem([<span class=hljs-number >999.0</span>,<span class=hljs-number >1</span>,<span class=hljs-number >0</span>],(<span class=hljs-number >0.0</span>,<span class=hljs-number >250.0</span>))
jump_iipprob = JumpProblem(iip_prob,Direct(),rj)
<span class=hljs-meta >@time</span> sol = solve(jump_iipprob,TauLeaping())</code></pre> <p>This is compatible with all of the other parts of DifferentialEquations.jl like event handling, ensemble simulations, and more.</p> <h2 id=jump_diffusion_euler-maruyama_and_implicit_euler-maruyama ><a href="#jump_diffusion_euler-maruyama_and_implicit_euler-maruyama" class=header-anchor >Jump Diffusion Euler-Maruyama and Implicit Euler-Maruyama</a></h2> <p>Continuing with the theme of jump equations, Euler-Maruyama and Implicit Euler-Maruyama are now compatible with JumpProblem definitions, meaning that equations like jump diffusions can now be directly solved with non-adaptive jumps via Poisson additions. In the following we see the same discrete-jump SIR model, now with Euler-Maruyama:</p> <pre><code class="julia hljs"><span class=hljs-keyword >function</span> rate_oop(u,p,t)
    [(<span class=hljs-number >0.1</span>/<span class=hljs-number >1000.0</span>)*u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>],<span class=hljs-number >0.01</span>u[<span class=hljs-number >2</span>]]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> regular_c(u,p,t,counts,mark)
    dc*counts
<span class=hljs-keyword >end</span>

rj = RegularJump(rate_oop,regular_c,<span class=hljs-number >2</span>)
foop(u,p,t) = [<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>]
goop(u,p,t) = [<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>]
oop_sdeprob = SDEProblem(foop,goop,[<span class=hljs-number >999.0</span>,<span class=hljs-number >1</span>,<span class=hljs-number >0</span>],(<span class=hljs-number >0.0</span>,<span class=hljs-number >250.0</span>))
jumpdiff_prob = JumpProblem(oop_sdeprob,Direct(),rj)
<span class=hljs-meta >@time</span> sol = solve(jumpdiff_prob,EM();dt=<span class=hljs-number >1.0</span>)</code></pre> <p>Now you see that there&#39;s <code>f</code> and <code>g</code> ready to be changed to mix and match continuous and discrete stochastic behaviors. This is an extension of our previous <a href="https://diffeq.sciml.ai/stable/tutorials/jump_diffusion/">jump diffusion support</a> by incorporating non-adapted jumping, allowing for scaling to jumps with higher rates.</p> <h2 id=adjoints_of_stochastic_differential_equations_and_new_sde_fitting_tutorials ><a href="#adjoints_of_stochastic_differential_equations_and_new_sde_fitting_tutorials" class=header-anchor >Adjoints of Stochastic Differential Equations and new SDE Fitting Tutorials</a></h2> <p>Stochastic differential equations now have <a href="https://frankschae.github.io/post/gsoc2020-high-weak-order-solvers-sde-adjoints/">adjoint definitions defined</a> which have extra optimizations on diagonal noise SDEs. This extends a <a href="https://gist.github.com/ChrisRackauckas/6a03e7b151c86b32d74b41af54d495c6">comparatively high performing SDE solver</a> to have low-memory SDE fitting. A <a href="https://diffeqflux.sciml.ai/dev/examples/optimization_sde/">new tutorial in DiffEqFlux</a> demonstrates how to recover the parameters of an SDE with just a few minutes of compute. Thank <a href="https://github.com/frankschae">@frankschae</a> for this advance&#33;</p> <h2 id=tons_of_methods_for_high_weak_order_solving_of_sdes ><a href="#tons_of_methods_for_high_weak_order_solving_of_sdes" class=header-anchor >Tons of methods for high weak order solving of SDEs</a></h2> <p>Due once again to <a href="https://github.com/frankschae">@frankschae</a>, we have plenty of new <a href="https://diffeq.sciml.ai/dev/solvers/sde_solve/#High-Weak-Order-Methods-1">high weak order methods</a> for fast solving of SDEs. When paired with <a href="https://github.com/SciML/DiffEqGPU.jl">recent performance improvements of DiffEqGPU</a>, we see some massive performance advantages for fitting expectations of equations. Formal benchmarks will come soon&#33;</p> <h2 id=continuous_normalizing_flows_and_ffjord_layers ><a href="#continuous_normalizing_flows_and_ffjord_layers" class=header-anchor >Continuous Normalizing Flows and FFJORD Layers</a></h2> <p>DiffEqFlux now provides <a href="https://diffeqflux.sciml.ai/dev/layers/CNFLayer/">pre-built continuous normalizing flow and FFJORD layers</a> for doing common neural ODE based machine learning. <a href="https://diffeqflux.sciml.ai/dev/examples/normalizing_flows/">A new tutorial</a> demonstrates how to get up and running with these layers in just a matter of minutes. This brings <a href="https://gist.github.com/ChrisRackauckas/4a4d526c15cc4170ce37da837bfc32c4">a system demonstrated to have a 100x neural ODE training advantage over PyTorch</a> into the land of continuous normalizing flow modeling. Thank <a href="https://github.com/d-netto">Diogo Netto &#40;@d-netto&#41;</a> and <a href="https://github.com/avik-pal">Avik Pal &#40;@avik-pal&#41;</a> for these strong contributions to the SciML ecosystem&#33;</p> <h2 id=sparse_matrix_support_in_odesdedae_adjoints ><a href="#sparse_matrix_support_in_odesdedae_adjoints" class=header-anchor >Sparse Matrix Support in ODE/SDE/DAE Adjoints</a></h2> <p>The whole SciML ecosystem has already been making use of <a href="https://openreview.net/pdf?id&#61;rJlPdcY38B">automated sparsity tooling</a> and now it has improved. Now automated sparse differentiation is performed in the backpass of a differential equation adjoint system using the derived sparsity patterns. This greatly accelerates adjoints of stiff equations, like large partial differential equations. All that is required is for sparse differentiation to be used for the forward solve and the system will kick in and automatically derive and apply it to the reverse.</p> <h1 id=next_directions_google_summer_of_code ><a href="#next_directions_google_summer_of_code" class=header-anchor >Next Directions: Google Summer of Code</a></h1> <p>The next directions are going to be highly tied to the directions that we are going with the latest Google Summer of Code, so here are a few things to look forward to:</p> <ul> <li><p>Some tooling for automated training of physics-informed neural networks &#40;PINNs&#41; from ModelingToolkit symbolic descriptions of the PDE.</p> <li><p>More Lie Group integrator methods.</p> <li><p>Higher efficiency low-storage Runge-Kutta methods with a demonstration of optimality in a large-scale climate model &#40;&#33;&#33;&#33;&#41;.</p> <li><p>More high weak order methods for SDEs</p> <li><p>Causal components in ModelingToolkit</p> </ul> <p>And many many more. There will be enough that I don&#39;t think we will wait a whole month for the next update, so see you soon&#33;</p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>