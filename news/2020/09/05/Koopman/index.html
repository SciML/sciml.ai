<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> SciML Ecosystem Update: Koopman Optimization Under Uncertainty, Non-Commutative SDEs, GPUs in R, and More </title> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <header> <h1><b><center>SciML Scientific Machine Learning Software</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/showcase/">Showcase</a> | <a href="/challenge/">Challenge Problems</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="/dev/">Dev Programs</a> | <a href="/governance/">Governance</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> | <a href="https://numfocus.org/donate-to-sciml">Donate</a> </nav> </header> <div class=franklin-content ><h1 id=sciml_ecosystem_update_koopman_optimization_under_uncertainty_non-commutative_sdes_gpus_in_r_and_more ><a href="#sciml_ecosystem_update_koopman_optimization_under_uncertainty_non-commutative_sdes_gpus_in_r_and_more" class=header-anchor >SciML Ecosystem Update: Koopman Optimization Under Uncertainty, Non-Commutative SDEs, GPUs in R, and More</a></h1> <p>This update comes at the conclusion of our summer. As other projects have been coming to an end, the underlying components that made a lot of the recent progress possible has been documented and solidified. Thus this release is a grab bag of exciting components which are used as the building blocks are larger numerical algorithms and problem solvers, along with documentation releases for major portions that have had lots of recent development. Let&#39;s dig in&#33;</p> <h2 id=diffequncertaintyjl_optimization_under_uncertainty_with_koopman_operators ><a href="#diffequncertaintyjl_optimization_under_uncertainty_with_koopman_operators" class=header-anchor >DiffEqUncertainty.jl: Optimization Under Uncertainty with Koopman Operators</a></h2> <p><img src="https://user-images.githubusercontent.com/1814174/92310533-6acd2080-ef7d-11ea-8ac2-67c1f248f372.PNG" alt="Koopman Speed" /></p> <p>We have recently released a new preprint <a href="https://arxiv.org/abs/2008.08737">demonstrating a new method for highly efficient uncertainty quantification with respect to parametric and process noise</a> using the Koopman expectation. This method is released as part of the <a href="https://github.com/SciML/DiffEqUncertainty.jl">DiffEqUncertainty.jl expectation interface</a> which now allows for fast computation of expected values with respect to distributional inputs. We demonstrate how this gives more than 1,000x faster calculations of moments than naive Monte Carlo calculations. If you haven&#39;t seen it, check out <a href="https://www.youtube.com/watch?v&#61;gbRG5VHkhsY">Adam Gerlach&#39;s JuliaCon 2020 video describing the method and the results</a>. For a quick introduction, check out the <a href="https://tutorials.sciml.ai/html/DiffEqUncertainty/01-expectation_introduction.html">new expectation tutorial</a>.</p> <p>The <code>expectation</code> function is differentiable, meaning that one can quickly optimize the expected value of the solution of a differential equation with respect its quantified uncertainties simply by placing it in an optimization context. That is demonstrated in <a href="https://tutorials.sciml.ai/html/DiffEqUncertainty/02-AD_and_optimization.html">this new tutorial demonstrating how to optimize controls with respect to uncertainty</a>.</p> <p>We will continue to improve the documentation of the aspects of the ecosystem around uncertainty quantification and believe that this may be one of the most exciting aspects to start integrating with our other SciML tooling.</p> <h2 id=strong_order_10_integrators_for_non-commutative_noise_sdes ><a href="#strong_order_10_integrators_for_non-commutative_noise_sdes" class=header-anchor >Strong Order 1.0 Integrators for Non-Commutative Noise SDEs</a></h2> <p>This is one of the most exciting portions to me since the adaptive SDE solvers are one of the oldest projects in the DifferentialEquations.jl suite and thus the SciML ecosystem. Something that was always held off was the Wiktorsson approximations for higher order non-commutative noise SDE solvers. For those who aren&#39;t deep in that discipline, this is a method which allows for higher strong order timestepping on any possible SDE. Before we had specific forms: scalar noise, diagonal noise, and commutative noise. However, now we have reached the final goal: higher strong order adaptive time stepping with general noise.</p> <p>With this release we have <code>RKMilGeneral</code>, which is a well-optimized method for strong order 1.0 stepping of general stochastic differential equations. It has all of the performance enhancements of StochasticDiffEq.jl that you&#39;d expect. Most importantly, the completion of the Wiktorsson approximation components enables many other strong order 1.0 methods to be easily created, meaning we will soon fill the library with the whole literature of possible methods. Thank Deepesh Singh Thakur &#40;@deeepeshthakur&#41; and @frankschae for this amazing achievement.</p> <h2 id=differentiable_quadrature_with_quadraturejl ><a href="#differentiable_quadrature_with_quadraturejl" class=header-anchor >Differentiable Quadrature with Quadrature.jl</a></h2> <p>Under the hood in the Koopman <code>expectation</code> calculation is a quadrature. To achieve the goals we needed to, we have developed a new Quadrature library <a href="https://github.com/SciML/Quadrature.jl">Quadrature.jl</a>. Quadrature.jl is a metapackage which brings together all of the quadrature packages in the Julia ecosystem, meaning that you can define a problem once and switch between any of the integration methods. However, the metapackage interface is only the start&#33;</p> <p>Quadrature.jl exposes a batched interface, giving caller-side controls that allow for parallelism. For example, in the following we multithread the integrand calculations for Cubature.jl:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Quadrature, Cubature, Base.Threads
<span class=hljs-keyword >function</span> f(dx,x,p)
  Threads.<span class=hljs-meta >@threads</span> <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:size(x,<span class=hljs-number >2</span>)
    dx[i] = sum(sin.(<span class=hljs-meta >@view</span>(x[:,i])))
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
prob = QuadratureProblem(f,ones(<span class=hljs-number >2</span>),<span class=hljs-number >3</span>ones(<span class=hljs-number >2</span>),batch=<span class=hljs-number >2</span>)
sol = solve(prob,CubatureJLh(),reltol=<span class=hljs-number >1e-3</span>,abstol=<span class=hljs-number >1e-3</span>)</code></pre> <p>This problem/solve setup follows the SciML standard conventions, making it easy to map over to other tools like <a href="https://github.com/SciML/AutoOptimize.jl">AutoOptimize.jl</a> and <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> in the near future.</p> <p>But what this common interface also let&#39;s us do is define hooks into the Julia automatic differentiation libraries such that all of the quadrature methods are differentiable. Thus Quadrature.jl <code>solve</code> calls can be directly used inside of Zygote differentiation. For example, the following does a two-dimensional integral with <a href="http://www.feynarts.de/cuba/">CUBA&#39;s Cuhre method</a> and then automatically defines the backpass to allow for gradients:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Quadrature, ForwardDiff, FiniteDiff, Zygote, Cuba
f(x,p) = sum(sin.(x .* p))
lb = ones(<span class=hljs-number >2</span>)
ub = <span class=hljs-number >3</span>ones(<span class=hljs-number >2</span>)
p = [<span class=hljs-number >1.5</span>,<span class=hljs-number >2.0</span>]

<span class=hljs-keyword >function</span> testf(p)
    prob = QuadratureProblem(f,lb,ub,p)
    sin(solve(prob,CubaCuhre(),reltol=<span class=hljs-number >1e-6</span>,abstol=<span class=hljs-number >1e-6</span>)[<span class=hljs-number >1</span>])
<span class=hljs-keyword >end</span>
dp1 = Zygote.gradient(testf,p)</code></pre> <p>Overloads also give non-Julia quadrature methods compatibility with forward-mode automatic differentiation via ForwardDiff.jl, meaning that both forward and reverse are possible. With this, high dimensional quadrature schemes can be mixed with all kinds of problems like training neural networks and Bayesian estimation.</p> <h2 id=gpu_accelerated_differential_equation_solving_in_r_with_diffeqr_10 ><a href="#gpu_accelerated_differential_equation_solving_in_r_with_diffeqr_10" class=header-anchor >GPU Accelerated Differential Equation Solving in R with diffeqr 1.0</a></h2> <p>diffeqr, the DifferentialEquations.jl&#39;s R counterpart, got its 1.0 release demonstrating new accelerations, including GPU support. Check out <a href="https://www.stochasticlifestyle.com/gpu-accelerated-ode-solving-in-r-with-julia-the-language-of-libraries/">this new blog post</a> which describes how to solve an ensemble of ODEs 350x faster than deSolve in pure R.</p> <h2 id=differentiable_molecular_dynamics_performance ><a href="#differentiable_molecular_dynamics_performance" class=header-anchor >Differentiable Molecular Dynamics Performance</a></h2> <p>Our differentiable molecular dynamics libraries, <a href="https://github.com/SciML/NBodySimulator.jl">NBodySimulator.jl</a> and <a href="https://github.com/JuliaMolSim/Molly.jl">Molly.jl</a> continue to improve thanks to the work of Sebastian Micluta-Campeanu &#40;@SebastianM-C&#41;. His latest blog post <a href="https://nextjournal.com/SebastianM-C/a-fresh-approach-to-n-body-problems?token&#61;2QnKjKYpnF5UYrB6ECZCYn">A fresh approach to N-body problems</a>, digs into the details for the optimizations that are being performed on the latest libraries. While these are still in their early stage, we have already found some exciting new results and will be continuing this project over at least the next few years.</p> <h2 id=reservoircomputingjl_documentation ><a href="#reservoircomputingjl_documentation" class=header-anchor >ReservoirComputing.jl Documentation</a></h2> <p><a href="https://reservoir.sciml.ai/dev/">ReservoirComputing.jl has released its documentation</a> detailing how to do high performance training of echo state networks and other reservoir-based machine learning methods. <a href="https://reservoir.sciml.ai/dev/examples/esn/">Take a look at the first tutorial training an echo state network to predict the chaotic outputs of the Lorenz equation</a>. This direction is particularly exciting and we plan to help accelerate its developments over the next year.</p> <h2 id=physics-informed_neural_networks_systems_of_equations_pdaes_and_more ><a href="#physics-informed_neural_networks_systems_of_equations_pdaes_and_more" class=header-anchor >Physics-Informed Neural Networks: Systems of equations, PDAEs, and more</a></h2> <p>The last release blog post was directly focused on NeuralPDE.jl so I did not want to make it the headliner again, but it very much could have. This release has had major additions to NeuralPDE.jl, such as handling of systems of equations and partial differential-algebraic equations, along with a lot of demonstrations on higher order PDEs. <a href="https://nextjournal.com/kirill_zubov/physics-informed-neural-networks-pinns-solver-on-julia-gsoc-2020-final-report">See Kirill&#39;s latest blog post for more information on this.</a></p> <h2 id=reactionnetworkimportersjl_bionetgen_and_cellml_support_on_catalyst ><a href="#reactionnetworkimportersjl_bionetgen_and_cellml_support_on_catalyst" class=header-anchor >ReactionNetworkImporters.jl &#40;BioNetGen&#41; and CellML Support on Catalyst</a></h2> <p>The Catalyst.jl and ModelingToolkit.jl ecosystem is growing fast&#33; <a href="https://github.com/isaacsas/ReactionNetworkImporters.jl">ReactionNetworkImporters.jl</a> is a package for importing BioNetGen models. <a href="https://github.com/SciML/CellMLToolkit.jl">CellMLToolkit.jl</a> is a package for importing CellML files. SBML and FMU support is soon to come.</p> <h2 id=differentialequationsjl_solvers_micro_tested_against_boost_c_with_vcl ><a href="#differentialequationsjl_solvers_micro_tested_against_boost_c_with_vcl" class=header-anchor >DifferentialEquations.jl Solvers Micro Tested Against Boost C&#43;&#43; with VCL</a></h2> <p>We thank Daniel Nagy for this demonstration testing the speed of RK4 on very small ODEs &#40;Lorenz&#41; against Boost C&#43;&#43; with and without VCL. Thank you Chris Elrod &#40;@celrod&#41; for helping maximize our vectorization in these cases. We can now demonstrate on CPUs that we are able to outperform Boost with VCL. Note that this simply corresponds to the cost of solving asymptotically small ODEs and does not impact most other usage, though a lot of users who do small ODE optimization will likely be interested in the little bits of performance gains seen in our latest updates. Improvements along these lines for ensemble GPU methods are coming soon.</p> <p><img src="https://user-images.githubusercontent.com/1814174/91665075-1af3e280-eac1-11ea-8fce-a0f311db05de.png" alt="Boost VCL vs Julia DifferentialEquations.jl" /></p> <h1 id=next_directions ><a href="#next_directions" class=header-anchor >Next Directions</a></h1> <p>The next directions are going to be highly tied to the directions that we are going with the latest Google Summer of Code, so here are a few things to look forward to:</p> <ul> <li><p>Higher efficiency low-storage Runge-Kutta methods with a demonstration of optimality in a large-scale climate model &#40;&#33;&#33;&#33;&#41;.</p> <li><p>Continued improvements to parallel and sparse automatic differentiation.</p> <li><p>More performance</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>