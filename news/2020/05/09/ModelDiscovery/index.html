<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> SciML Ecosystem Update: Automated Model Discovery with DataDrivenDiffEq.jl and ReservoirComputing.jl </title> <header> <h1><b><center>SciML Open Source Scientific Machine Learning</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>﻿ You give us data and we give you back LaTeX for the differential equation system that generated the data. That may sound like the future, but the future is here. In this SciML ecosystem update I am pleased to announce that a lot of our data-driven modeling components are finally released with full documentation. Let&#39;s dive right in&#33;</p> <h2 id=datadrivendiffeqjl_dynamic_mode_decomposition_and_sparse_identification_of_models ><a href="#datadrivendiffeqjl_dynamic_mode_decomposition_and_sparse_identification_of_models">DataDrivenDiffEq.jl: Dynamic Mode Decomposition and Sparse Identification of Models</a></h2> <p><a href="https://github.com/SciML/DataDrivenDiffEq.jl">DataDrivenDiffEq.jl</a> has arrived, complete with <a href="https://datadriven.sciml.ai/dev/">documentation</a> and a <a href="https://github.com/SciML/DataDrivenDiffEq.jl/tree/master/examples">full set of examples</a>. Thank Julius Martensen &#40;@AlCap23&#41; for really driving this effort. You can use this library to identify the sparse functional form of a differential equation via variants of the <a href="https://www.pnas.org/content/113/15/3932">SInDy method</a> given data and discover large linear ODEs on a basis of chosen observables through variants of <a href="https://en.wikipedia.org/wiki/Dynamic_mode_decomposition">dynamic mode decomposition</a>. This library has many options for how the sparsification and optimization are performed to ensure it&#39;s robust, and integrates with <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> so that the trained basis functions work with symbolic libraries and have automatic LaTeXification via <a href="https://github.com/korsbo/Latexify.jl">Latexify.jl</a>. And, as demonstrated in the <a href="https://arxiv.org/abs/2001.04385">universal differential equations paper</a> and highlighted in <a href="https://www.youtube.com/watch?v&#61;SEhMWkgcTOI">this presentation on generalized physics-informed learning</a>, these techniques can also be mixed with DiffEqFlux.jl and neural networks to allow for pre-specifying known physics and discovering parts of models in a robust fashion.</p> <p>As a demonstration, let&#39;s generate some data from a pendulum:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> DataDrivenDiffEq
<span class=hljs-keyword >using</span> ModelingToolkit
<span class=hljs-keyword >using</span> OrdinaryDiffEq
<span class=hljs-keyword >using</span> LinearAlgebra
<span class=hljs-keyword >using</span> Plots
gr()

<span class=hljs-keyword >function</span> pendulum(u, p, t)
    x = u[<span class=hljs-number >2</span>]
    y = -<span class=hljs-number >9.81</span>sin(u[<span class=hljs-number >1</span>]) - <span class=hljs-number >0.1</span>u[<span class=hljs-number >2</span>]
    <span class=hljs-keyword >return</span> [x;y]
<span class=hljs-keyword >end</span>

u0 = [<span class=hljs-number >0.4</span><span class=hljs-literal >π</span>; <span class=hljs-number >1.0</span>]
tspan = (<span class=hljs-number >0.0</span>, <span class=hljs-number >20.0</span>)
problem = ODEProblem(pendulum, u0, tspan)
solution = solve(problem, Tsit5(), atol = <span class=hljs-number >1e-8</span>, rtol = <span class=hljs-number >1e-8</span>, saveat = <span class=hljs-number >0.001</span>)

X = <span class=hljs-built_in >Array</span>(solution)
DX = solution(solution.t, <span class=hljs-built_in >Val</span>{<span class=hljs-number >1</span>})</code></pre> <p>Let&#39;s automatically discover that differential equation from its timeseries. Now to perform SInDy, we define a set of basis functions via ModelingToolkit.jl:</p> <pre><code class="julia hljs"><span class=hljs-meta >@variables</span> u[<span class=hljs-number >1</span>:<span class=hljs-number >2</span>]
h = Operation[u; u.^<span class=hljs-number >2</span>; u.^<span class=hljs-number >3</span>; sin.(u); cos.(u); <span class=hljs-number >1</span>]
basis = Basis(h, u)</code></pre> <p>Here we included a bunch of polynomials up to third order and some trigonometric functions. Now we tell SInDy what the timeseries data is and what the basis is and it&#39;ll spit out the differential equation system:</p> <pre><code class="julia hljs">opt = SR3(<span class=hljs-number >3e-1</span>, <span class=hljs-number >1.0</span>)
Ψ = SInDy(X[:, <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>], DX[:, <span class=hljs-number >1</span>:<span class=hljs-number >1000</span>], basis, maxiter = <span class=hljs-number >10000</span>, opt = opt, normalize = <span class=hljs-literal >true</span>)</code></pre> <pre><code class="julia hljs"><span class=hljs-number >2</span> dimensional basis <span class=hljs-keyword >in</span> [<span class=hljs-string >&quot;u₁&quot;</span>, <span class=hljs-string >&quot;u₂&quot;</span>]
du₁ = p₁ * u₂
du₂ = sin(u₁) * p₃ + p₂ * u₂</code></pre> <p>And there you go: notice that it was able to find the right structural equations&#33; <code>Ψ</code> is now of the form of the right differential equation, just from the data. We can then transform this back into DifferentialEquations.jl code to see how well we&#39;ve identified the system and its coefficients:</p> <pre><code class="julia hljs">sys = ODESystem(Ψ)
p = parameters(Ψ)

dudt = ODEFunction(sys)

estimator = ODEProblem(dudt, u0, tspan, p)
estimation = solve(estimator, Tsit5(), saveat = solution.t)</code></pre> <p><img src="https://user-images.githubusercontent.com/1814174/81472998-c9e67880-91c9-11ea-919b-b712f17abc80.png" alt="" /></p> <p>We can now do things like, reoptimize the parameters with DiffEqParamEstim.jl or DiffEqFlux.jl, or look at the AIC/BIC of the fit, or etc.jl. See the <a href="https://datadriven.sciml.ai/dev/">DataDrivenDiffEq.jl documentation</a> for more details on all that you can do. We hope that by directly incorporating this into the SciML ecosystem that it will become a standard part of the scientific modeling workflow and will continue to improve its methods.</p> <h2 id=automatic_discovery_of_chaotic_systems_via_reservoircomputingjl ><a href="#automatic_discovery_of_chaotic_systems_via_reservoircomputingjl">Automatic Discovery of Chaotic Systems via ReservoirComputing.jl</a></h2> <p>Traditional methods of neural differential equations do not do so well on chaotic systems, but the Echo State Network techniques in <a href="https://github.com/SciML/ReservoirComputing.jl">ReservoirComputing.jl</a> do&#33; Big thanks to @MartinuzziFrancesco who has been driving this effort. This library is able to train neural networks that learn attractor behavior and then predict the evolution of chaotic systems. More development will soon follow on this library as it was <a href="https://summerofcode.withgoogle.com/organizations/6363760870031360/?sp-page&#61;2#5374375945043968">chosen to be one of the JuliaLang Google Summer of Code projects</a>.</p> <p><img src="https://user-images.githubusercontent.com/10376688/72997095-1913c380-3dfc-11ea-9702-a9734a375b96.png" alt="" /></p> <h2 id=high_weak_order_sde_integrators ><a href="#high_weak_order_sde_integrators">High Weak Order SDE Integrators</a></h2> <p>As part of our continued work on <a href="https://docs.sciml.ai/latest/">DifferentialEquations.jl</a> we have added new stochastic differential equation integrators, <code>DRI1</code> and <code>RI1</code>, which are able to better estimate the expected value of the solution without requiring the computational overhead of getting high order strong convergence. This is only the start of a much larger project that we have accepted for <a href="https://summerofcode.withgoogle.com/organizations/6363760870031360/#5505348691034112">JuliaLang&#39;s Google Summer of Code</a>. Thank Frank Schafer &#40;@frankschae&#41; for driving this effort. He will be continuing to add methods for high weak convergence and fast methods for SDE adjoints to further improve DiffEqFlux.jl&#39;s neural stochastic differential equation support.</p> <h2 id=sundials_5_and_lapack_integration ><a href="#sundials_5_and_lapack_integration">Sundials 5 and LAPACK Integration</a></h2> <p>Sundials.jl now utilizes the latest version of Sundials, Sundials 5, for its calculations. Thanks to Jose Daniel Lara &#40;@jd-lara&#41; for driving this effort. Included with this update is the ability to use LAPACK/BLAS. This is not enabled by default because it&#39;s slower on small matrices, but if you&#39;re handling a large problem with Sundials, you can now do <code>CVODE_BDF&#40;linear_solver&#61;:LapackDense&#41;</code> and boom now all of the linear algebra is multithreaded BLASy goodness.</p> <h2 id=diffeqbayes_updates ><a href="#diffeqbayes_updates">DiffEqBayes Updates</a></h2> <p>Thanks to extensive maintanance efforts by Vaibhav Dixit &#40;@Vaibhavdixit02&#41;, David Widmann &#40;@devmotion&#41;, Kai Xu &#40;@xukai92&#41;, Mohammad Tarek &#40;@mohamed82008&#41;, and Rob Goedman &#40;@goedman&#41;, the DiffEqBayes.jl library has received plenty of updates to utilize the most up-to-date versions of the <a href="https://github.com/TuringLang/Turing.jl">Turing.jl</a>, <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>, and <a href="https://mc-stan.org/users/interfaces/julia-stan">Stan</a> probabilistic programming libraries &#40;<a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit.jl</a> automatically transforms Julia differential equation code to Stan&#41;. Together, this serves as a very good resource for non-Bayesian-inclined users to utilize Bayesian parameter estimation with just one function. <a href="https://docs.sciml.ai/latest/analysis/parameter_estimation/">See the parameter estimation documentation for more details</a>.</p> <p>As a quick update to the probabilistic programming space, we would like to note that the Turing.jl library performs exceptionally well in comparison to the other libraries. A lot of work had to be done in order to <a href="https://github.com/SciML/DiffEqBayes.jl/pull/154">specifically find robustness issues in Stan</a> and <a href="https://github.com/SciML/DiffEqBayes.jl/pull/155">make the priors more constrained</a>, while Turing.jl has had no issues. This has shown up in other places as well, where <a href="https://github.com/SciML/DiffEqBenchmarks.jl/blob/510c3683aa00ffa8e96e5c25bb07ef9301a06251/pdf/ParameterEstimation/DiffEqBayesLorenz.pdf">we have not been able to update our Bayesian Lorenz parameter estimation benchmarks due to robustness issues with Stan diverging</a> Additionally, <a href="https://benchmarks.sciml.ai/html/ParameterEstimation/DiffEqBayesLotkaVolterra.html">benchmarks on</a> <a href="https://benchmarks.sciml.ai/html/ParameterEstimation/DiffEqBayesFitzHughNagumo.html">other ODE systems</a> demonstrate a 5x and 3x performance advantage for Turing over Stan. Thus our examples showcase Turing.jl as being unequivically more robust for Bayesian parameter estimation of differential equation systems. We hope that, with the automatic differential equation conversion making testing between all of these libraries easy, we can easily track performance and robustness improvements to these probabilistic programming backends over time and ensure that users can continue to know and use the best tools for the job.</p> <h1 id=next_directions ><a href="#next_directions">Next Directions</a></h1> <p>Here&#39;s some things to look forward to:</p> <ul> <li><p>SuperLU_MT support in Sundials.jl</p> <li><p>The full release of ModelingToolkit.jl</p> <li><p>Automated matrix-free finite difference PDE operators</p> <li><p>High Strong Order Methods for Non-Commutative Noise SDEs</p> <li><p>Stochastic delay differential equations</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>