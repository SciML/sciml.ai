<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title>DifferentialEquations.jl v7: New linear solver and preconditioner interface</title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://benchmarks.sciml.ai/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/coc/">Code of Conduct</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=differentialequationsjl_v7_new_linear_solver_and_preconditioner_interface ><a href="#differentialequationsjl_v7_new_linear_solver_and_preconditioner_interface" class=header-anchor >DifferentialEquations.jl v7: New linear solver and preconditioner interface</a></h1> <p>An update is long overdue and this is a really nice one&#33; DifferentialEquations.jl v7 has been released, the first major version since 2019&#33; We note that, as a major version, this does indicate breaking API changes have been introduced. That said, they are relatively minor and only involve the linear solver interface, which is the main topic of this release post.</p> <p>Before we move on, I want to mention that all of your support helps. Thank you very much&#33; If you do not have anything to donate, you can still help by starring the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> and other Github repositories in the <a href="https://github.com/SciML">SciML Organization</a>. If you do have funds, please consider <a href="https://github.com/sponsors/SciML">becoming a sponsor</a>. The next set of tools, like tutorials showing large sparse PDEs solved using Distributed and GPUs, will require support from viewers like you. Now back to the show.</p> <h2 id=linearsolvejl_a_common_interface_for_linear_solvers ><a href="#linearsolvejl_a_common_interface_for_linear_solvers" class=header-anchor >LinearSolve.jl: A common interface for linear solvers</a></h2> <p>Julia has built in linear solvers, so why does this library exist? The problem is that the person who writes a library may not be the person who can make the best choice for how a linear system is solved. Thus while <code>A\b</code> looks like the &quot;best&quot; way to solve <code>Ax&#61;b</code>, in reality there are many ways to do it:</p> <ul> <li><p><code>lu&#40;A&#41;\b</code> is the fastest of the factorizations for standard matrices, but if the matrix is positive definite then <code>cholesky&#40;A&#41;\b</code> can be faster, etc. And if the matrix is ill-conditioned then <code>qr&#40;A&#41;\b</code> will have less numerical error.</p> <li><p>When you get to sparse arrays, there are many different LU-factorizations, like <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a> as an alternative to the standard UMFPACK one, which will be better or worse depending on the sparsity pattern.</p> <li><p>There are methods which do not require constructing the full <code>A</code> matrix, like <a href="https://github.com/JuliaLinearAlgebra/IterativeSolvers.jl">IterativeSolvers.jl</a> or <a href="https://github.com/JuliaSmoothOptimizers/Krylov.jl">Krylov.jl</a> Krylov-subspace methods. These cannot be represented by a simple <code>\</code> because they require specifying a tolerance.</p> </ul> <p>Thus, how can you write a library but expose the linear solver choice to the user? The answer is LinearSolve.jl. Let&#39;s see it in action. Solve <code>Ax&#61;b</code> with the default method:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearSolve

A = rand(<span class=hljs-number >4</span>,<span class=hljs-number >4</span>)
b = rand(<span class=hljs-number >4</span>)
prob = LinearProblem(A, b)
sol = solve(prob)
sol.u</code></pre> <p>Now let&#39;s choose an LU-factorization:</p> <pre><code class="julia hljs">sol = solve(prob,LUFactorization())</code></pre>
<p>And now what about using GMRES with a relative tolerance of <code>1e-7</code>?</p>
<pre><code class="julia hljs">sol = solve(prob,KrylovJL_GMRES(),reltol=<span class=hljs-number >1e-7</span>)</code></pre>
<p>Notice this all follows the <a href="https://scimlbase.sciml.ai/dev/">SciML Common Interface</a> and thus has the same look and feel as <a href="https://nonlinearsolve.sciml.ai/dev/">NonlinearSolve.jl</a>, <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl</a>, and <a href="https://galacticoptim.sciml.ai/dev/">GalacticOptim.jl</a>. There are many nice features in there, such as an iterative interface that helps with caching factorizations effectively. Thus for someone interesting in writing libraries which internally use linear solvers, this is a very nice target. In fact, that may be its main purpose, leading us to the next point.</p>
<h2 id=linearsolvejl_integration_into_differentialequationsjl ><a href="#linearsolvejl_integration_into_differentialequationsjl" class=header-anchor >LinearSolve.jl Integration into DifferentialEquations.jl</a></h2>
<p>The major breaking change of DifferentialEquations.jl v7 is the use of LinearSolve.jl for internal linear solves. Now, linear solvers for implicit algorithms are chosen by passing a <a href="http://linearsolve.sciml.ai/dev/solvers/solvers/">LinearSolve.jl solver</a> to the <code>linsolve</code> of compatible OrdinaryDiffEq.jl algorithms. This is all showcased in the new and improved <a href="https://diffeq.sciml.ai/stable/tutorials/advanced_ode_example/">scaling stiff ODE solvers for PDEs tutorial</a></p>
<p>For example, let&#39;s say we are solving this big Brusselator PDE:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> DifferentialEquations, LinearAlgebra, SparseArrays

<span class=hljs-keyword >const</span> N = <span class=hljs-number >32</span>
<span class=hljs-keyword >const</span> xyd_brusselator = range(<span class=hljs-number >0</span>,stop=<span class=hljs-number >1</span>,length=N)
brusselator_f(x, y, t) = (((x-<span class=hljs-number >0.3</span>)^<span class=hljs-number >2</span> + (y-<span class=hljs-number >0.6</span>)^<span class=hljs-number >2</span>) &lt;= <span class=hljs-number >0.1</span>^<span class=hljs-number >2</span>) * (t &gt;= <span class=hljs-number >1.1</span>) * <span class=hljs-number >5.</span>
limit(a, N) = a == N+<span class=hljs-number >1</span> ? <span class=hljs-number >1</span> : a == <span class=hljs-number >0</span> ? N : a
<span class=hljs-keyword >function</span> brusselator_2d_loop(du, u, p, t)
  A, B, alpha, dx = p
  alpha = alpha/dx^<span class=hljs-number >2</span>
  <span class=hljs-meta >@inbounds</span> <span class=hljs-keyword >for</span> I <span class=hljs-keyword >in</span> <span class=hljs-built_in >CartesianIndices</span>((N, N))
    i, j = <span class=hljs-built_in >Tuple</span>(I)
    x, y = xyd_brusselator[I[<span class=hljs-number >1</span>]], xyd_brusselator[I[<span class=hljs-number >2</span>]]
    ip1, im1, jp1, jm1 = limit(i+<span class=hljs-number >1</span>, N), limit(i-<span class=hljs-number >1</span>, N), limit(j+<span class=hljs-number >1</span>, N), limit(j-<span class=hljs-number >1</span>, N)
    du[i,j,<span class=hljs-number >1</span>] = alpha*(u[im1,j,<span class=hljs-number >1</span>] + u[ip1,j,<span class=hljs-number >1</span>] + u[i,jp1,<span class=hljs-number >1</span>] + u[i,jm1,<span class=hljs-number >1</span>] - <span class=hljs-number >4</span>u[i,j,<span class=hljs-number >1</span>]) +
                B + u[i,j,<span class=hljs-number >1</span>]^<span class=hljs-number >2</span>*u[i,j,<span class=hljs-number >2</span>] - (A + <span class=hljs-number >1</span>)*u[i,j,<span class=hljs-number >1</span>] + brusselator_f(x, y, t)
    du[i,j,<span class=hljs-number >2</span>] = alpha*(u[im1,j,<span class=hljs-number >2</span>] + u[ip1,j,<span class=hljs-number >2</span>] + u[i,jp1,<span class=hljs-number >2</span>] + u[i,jm1,<span class=hljs-number >2</span>] - <span class=hljs-number >4</span>u[i,j,<span class=hljs-number >2</span>]) +
                A*u[i,j,<span class=hljs-number >1</span>] - u[i,j,<span class=hljs-number >1</span>]^<span class=hljs-number >2</span>*u[i,j,<span class=hljs-number >2</span>]
    <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>
p = (<span class=hljs-number >3.4</span>, <span class=hljs-number >1.</span>, <span class=hljs-number >10.</span>, step(xyd_brusselator))

<span class=hljs-keyword >function</span> init_brusselator_2d(xyd)
  N = length(xyd)
  u = zeros(N, N, <span class=hljs-number >2</span>)
  <span class=hljs-keyword >for</span> I <span class=hljs-keyword >in</span> <span class=hljs-built_in >CartesianIndices</span>((N, N))
    x = xyd[I[<span class=hljs-number >1</span>]]
    y = xyd[I[<span class=hljs-number >2</span>]]
    u[I,<span class=hljs-number >1</span>] = <span class=hljs-number >22</span>*(y*(<span class=hljs-number >1</span>-y))^(<span class=hljs-number >3</span>/<span class=hljs-number >2</span>)
    u[I,<span class=hljs-number >2</span>] = <span class=hljs-number >27</span>*(x*(<span class=hljs-number >1</span>-x))^(<span class=hljs-number >3</span>/<span class=hljs-number >2</span>)
  <span class=hljs-keyword >end</span>
  u
<span class=hljs-keyword >end</span>
u0 = init_brusselator_2d(xyd_brusselator)
prob_ode_brusselator_2d = ODEProblem(brusselator_2d_loop,u0,(<span class=hljs-number >0.</span>,<span class=hljs-number >11.5</span>),p)</code></pre>
<p>We can first speed it up by using the automated sparsity detection of Symbolics.jl to generate a sparse Jacobian:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Symbolics
du0 = copy(u0)
jac_sparsity = Symbolics.jacobian_sparsity((du,u)-&gt;brusselator_2d_loop(du,u,p,<span class=hljs-number >0.0</span>),du0,u0)

<span class=hljs-number >2048</span>×<span class=hljs-number >2048</span> SparseArrays.SparseMatrixCSC{<span class=hljs-built_in >Bool</span>, <span class=hljs-built_in >Int64</span>} with <span class=hljs-number >12288</span> stored entries:
⠻⣦⡀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀⠀⠀
⠀⠈⠻⣦⡀⠀⠀⠀⠀⠈⠳⣄⠀⠀⠀⠀
⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀⠀⠈⠳⣄⠀⠀
⡀⠀⠀⠀⠀⠈⠻⣦⠀⠀⠀⠀⠀⠈⠳⣄
⠙⢦⡀⠀⠀⠀⠀⠀⠻⣦⡀⠀⠀⠀⠀⠈
⠀⠀⠙⢦⡀⠀⠀⠀⠀⠈⠻⣦⡀⠀⠀⠀
⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠈⠻⣦⡀⠀
⠀⠀⠀⠀⠀⠀⠙⢦⡀⠀⠀⠀⠀⠈⠻⣦</code></pre>
<p>which we then use to define an improved ODE:</p>
<pre><code class="julia hljs">f = ODEFunction(brusselator_2d_loop;jac_prototype=float.(jac_sparsity))
prob_ode_brusselator_2d_sparse = ODEProblem(f,u0,(<span class=hljs-number >0.</span>,<span class=hljs-number >11.5</span>),p)</code></pre>
<p>This will solve pretty fast:</p>
<pre><code class="julia hljs"><span class=hljs-meta >@btime</span> solve(prob_ode_brusselator_2d,TRBDF2(),save_everystep=<span class=hljs-literal >false</span>) <span class=hljs-comment ># 2.771 s (5452 allocations: 65.73 MiB)</span></code></pre>
<p>But we can swap it over to GMRES and get a nice speedup:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> LinearSolve
<span class=hljs-meta >@btime</span> solve(prob_ode_brusselator_2d,KenCarp47(linsolve=KrylovJL_GMRES()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-comment ># 707.439 ms (173868 allocations: 31.07 MiB)</span></code></pre>
<h2 id=preconditioner_interface ><a href="#preconditioner_interface" class=header-anchor >Preconditioner Interface</a></h2>
<p>With the change to LinearSolve.jl comes a new preconditioner interface. Any <a href="http://linearsolve.sciml.ai/dev/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used with any LinearSolve-based library. For example, let&#39;s change that PDE solve to use an ILU preconditioner:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> IncompleteLU
<span class=hljs-keyword >function</span> incompletelu(W,du,u,p,t,newW,Plprev,Prprev,solverdata)
  <span class=hljs-keyword >if</span> newW === <span class=hljs-literal >nothing</span> || newW
    Pl = ilu(convert(<span class=hljs-built_in >AbstractMatrix</span>,W), τ = <span class=hljs-number >50.0</span>)
  <span class=hljs-keyword >else</span>
    Pl = Plprev
  <span class=hljs-keyword >end</span>
  Pl,<span class=hljs-literal >nothing</span>
<span class=hljs-keyword >end</span>

<span class=hljs-comment ># Required due to a bug in Krylov.jl: https://github.com/JuliaSmoothOptimizers/Krylov.jl/pull/477</span>
Base.eltype(::IncompleteLU.ILUFactorization{Tv,Ti}) <span class=hljs-keyword >where</span> {Tv,Ti} = Tv

<span class=hljs-meta >@time</span> solve(prob_ode_brusselator_2d_sparse,KenCarp47(linsolve=KrylovJL_GMRES(),precs=incompletelu,concrete_jac=<span class=hljs-literal >true</span>),save_everystep=<span class=hljs-literal >false</span>);
<span class=hljs-comment ># 174.386 ms (61756 allocations: 61.38 MiB)</span></code></pre>
<h2 id=preconditioner_examples_with_sundialsjl ><a href="#preconditioner_examples_with_sundialsjl" class=header-anchor >Preconditioner Examples with Sundials.jl</a></h2>
<p>These preconditioners are also setup with Sundials.jl. For example, from the same tutorial:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> ModelingToolkit
prob_ode_brusselator_2d_mtk = ODEProblem(modelingtoolkitize(prob_ode_brusselator_2d_sparse),[],(<span class=hljs-number >0.0</span>,<span class=hljs-number >11.5</span>),jac=<span class=hljs-literal >true</span>,sparse=<span class=hljs-literal >true</span>);

<span class=hljs-keyword >using</span> LinearAlgebra
u0 = prob_ode_brusselator_2d_mtk.u0
p  = prob_ode_brusselator_2d_mtk.p
<span class=hljs-keyword >const</span> jaccache = prob_ode_brusselator_2d_mtk.f.jac(u0,p,<span class=hljs-number >0.0</span>)
<span class=hljs-keyword >const</span> W = I - <span class=hljs-number >1.0</span>*jaccache

prectmp = ilu(W, τ = <span class=hljs-number >50.0</span>)
<span class=hljs-keyword >const</span> preccache = <span class=hljs-built_in >Ref</span>(prectmp)

<span class=hljs-keyword >function</span> psetupilu(p, t, u, du, jok, jcurPtr, gamma)
  <span class=hljs-keyword >if</span> jok
    prob_ode_brusselator_2d_mtk.f.jac(jaccache,u,p,t)
    jcurPtr[] = <span class=hljs-literal >true</span>

    <span class=hljs-comment ># W = I - gamma*J</span>
    @. W = -gamma*jaccache
    idxs = diagind(W)
    @. <span class=hljs-meta >@view</span>(W[idxs]) = <span class=hljs-meta >@view</span>(W[idxs]) + <span class=hljs-number >1</span>

    <span class=hljs-comment ># Build preconditioner on W</span>
    preccache[] = ilu(W, τ = <span class=hljs-number >5.0</span>)
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> precilu(z,r,p,t,y,fy,gamma,delta,lr)
  ldiv!(z,preccache[],r)
<span class=hljs-keyword >end</span>

<span class=hljs-meta >@btime</span> solve(prob_ode_brusselator_2d_sparse,CVODE_BDF(linear_solver=:GMRES,prec=precilu,psetup=psetupilu,prec_side=<span class=hljs-number >1</span>),save_everystep=<span class=hljs-literal >false</span>);
<span class=hljs-comment ># 87.176 ms (17717 allocations: 77.08 MiB)</span></code></pre>
<p>This ends up being <a href="https://gist.github.com/ChrisRackauckas/0bdbea0079a8a3ce28522e9bc8473bf0">935x faster than the fastest vectorized implementation we could find for SciPy&#33;</a>. This is all algorithmic.</p>
<h2 id=greatly_improved_static_array_performance_in_ordinarydiffeqjl ><a href="#greatly_improved_static_array_performance_in_ordinarydiffeqjl" class=header-anchor >Greatly Improved Static Array Performance in OrdinaryDiffEq.jl</a></h2>
<p>As the opposite of large equations, static array performance for small equations was also greatly improved. Let&#39;s just see some before and afters:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq, StaticArrays, BenchmarkTools
<span class=hljs-keyword >function</span> rober(u,p,t)
  y₁,y₂,y₃ = u
  k₁,k₂,k₃ = p
  dy₁ = -k₁*y₁+k₃*y₂*y₃
  dy₂ =  k₁*y₁-k₂*y₂^<span class=hljs-number >2</span>-k₃*y₂*y₃
  dy₃ =  k₂*y₂^<span class=hljs-number >2</span>
  SA[dy₁,dy₂,dy₃]
<span class=hljs-keyword >end</span>
prob = ODEProblem{<span class=hljs-literal >false</span>}(rober,SA[<span class=hljs-number >1.0</span>,<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>],(<span class=hljs-number >0.0</span>,<span class=hljs-number >1e5</span>),SA[<span class=hljs-number >0.04</span>,<span class=hljs-number >3e7</span>,<span class=hljs-number >1e4</span>])
<span class=hljs-comment ># Defaults to reltol=1e-3, abstol=1e-6</span>
<span class=hljs-meta >@btime</span> sol = solve(prob,Rosenbrock23(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >3</span>}()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-meta >@btime</span> sol = solve(prob,Rodas4(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >3</span>}()),save_everystep=<span class=hljs-literal >false</span>)

<span class=hljs-comment ># Before:</span>
<span class=hljs-number >15.000</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >3.28</span> KiB)
<span class=hljs-number >25.900</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >4.22</span> KiB)

<span class=hljs-comment ># After</span>
<span class=hljs-number >9.000</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >3.03</span> KiB)
<span class=hljs-number >12.900</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >3.97</span> KiB)

<span class=hljs-keyword >using</span> OrdinaryDiffEq, StaticArrays, BenchmarkTools
<span class=hljs-keyword >function</span> hires_4(u,p,t)
  y1,y2,y3,y4 = u
  dy1 = -<span class=hljs-number >1.71</span>*y1 + <span class=hljs-number >0.43</span>*y2 + <span class=hljs-number >8.32</span>*y3 + <span class=hljs-number >0.0007</span>
  dy2 = <span class=hljs-number >1.71</span>*y1 - <span class=hljs-number >8.75</span>*y2
  dy3 = -<span class=hljs-number >10.03</span>*y3 + <span class=hljs-number >0.43</span>*y4 + <span class=hljs-number >0.035</span>*y2
  dy4 = <span class=hljs-number >8.32</span>*y2 + <span class=hljs-number >1.71</span>*y3 - <span class=hljs-number >1.12</span>*y4
  SA[dy1,dy2,dy3,dy4]
<span class=hljs-keyword >end</span>

u0 = SA[<span class=hljs-number >1</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0.0057</span>]
prob = ODEProblem(hires_4,u0,(<span class=hljs-number >0.0</span>,<span class=hljs-number >321.8122</span>))
<span class=hljs-comment ># Defaults to reltol=1e-3, abstol=1e-6</span>
<span class=hljs-meta >@btime</span> sol = solve(prob,Rosenbrock23(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >4</span>}()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-meta >@btime</span> sol = solve(prob,Rodas5(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >4</span>}()),save_everystep=<span class=hljs-literal >false</span>)

<span class=hljs-comment ># Before:</span>
<span class=hljs-number >22.200</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >3.36</span> KiB)
<span class=hljs-number >25.600</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >4.59</span> KiB)

<span class=hljs-comment ># Now</span>
<span class=hljs-number >11.200</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >3.36</span> KiB)
<span class=hljs-number >9.400</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >4.59</span> KiB)

<span class=hljs-keyword >using</span> OrdinaryDiffEq, StaticArrays, BenchmarkTools
<span class=hljs-keyword >function</span> hires_5(u,p,t)
  y1,y2,y3,y4,y5 = u
  dy1 = -<span class=hljs-number >1.71</span>*y1 + <span class=hljs-number >0.43</span>*y2 + <span class=hljs-number >8.32</span>*y3 + <span class=hljs-number >0.0007</span>
  dy2 = <span class=hljs-number >1.71</span>*y1 - <span class=hljs-number >8.75</span>*y2
  dy3 = -<span class=hljs-number >10.03</span>*y3 + <span class=hljs-number >0.43</span>*y4 + <span class=hljs-number >0.035</span>*y5
  dy4 = <span class=hljs-number >8.32</span>*y2 + <span class=hljs-number >1.71</span>*y3 - <span class=hljs-number >1.12</span>*y4
  dy5 = -<span class=hljs-number >1.745</span>*y5 + <span class=hljs-number >0.43</span>*y2 + <span class=hljs-number >0.43</span>*y4
  SA[dy1,dy2,dy3,dy4,dy5]
<span class=hljs-keyword >end</span>

u0 = SA[<span class=hljs-number >1</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0.0057</span>]
prob = ODEProblem(hires_5,u0,(<span class=hljs-number >0.0</span>,<span class=hljs-number >321.8122</span>))
<span class=hljs-comment ># Defaults to reltol=1e-3, abstol=1e-6</span>
<span class=hljs-meta >@btime</span> sol = solve(prob,Rosenbrock23(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >5</span>}()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-meta >@btime</span> sol = solve(prob,Rodas4(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >5</span>}()),save_everystep=<span class=hljs-literal >false</span>)

<span class=hljs-comment ># Before:</span>
<span class=hljs-number >30.200</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >4.03</span> KiB)
<span class=hljs-number >35.600</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >5.00</span> KiB)

<span class=hljs-comment ># Now</span>
<span class=hljs-number >23.000</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >4.03</span> KiB)
<span class=hljs-number >18.900</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >5.00</span> KiB)

<span class=hljs-keyword >using</span> OrdinaryDiffEq, StaticArrays, BenchmarkTools
<span class=hljs-keyword >function</span> hires(u,p,t)
  y1,y2,y3,y4,y5,y6,y7,y8 = u
  dy1 = -<span class=hljs-number >1.71</span>*y1 + <span class=hljs-number >0.43</span>*y2 + <span class=hljs-number >8.32</span>*y3 + <span class=hljs-number >0.0007</span>
  dy2 = <span class=hljs-number >1.71</span>*y1 - <span class=hljs-number >8.75</span>*y2
  dy3 = -<span class=hljs-number >10.03</span>*y3 + <span class=hljs-number >0.43</span>*y4 + <span class=hljs-number >0.035</span>*y5
  dy4 = <span class=hljs-number >8.32</span>*y2 + <span class=hljs-number >1.71</span>*y3 - <span class=hljs-number >1.12</span>*y4
  dy5 = -<span class=hljs-number >1.745</span>*y5 + <span class=hljs-number >0.43</span>*y6 + <span class=hljs-number >0.43</span>*y7
  dy6 = -<span class=hljs-number >280.0</span>*y6*y8 + <span class=hljs-number >0.69</span>*y4 + <span class=hljs-number >1.71</span>*y5 -
           <span class=hljs-number >0.43</span>*y6 + <span class=hljs-number >0.69</span>*y7
  dy7 = <span class=hljs-number >280.0</span>*y6*y8 - <span class=hljs-number >1.81</span>*y7
  dy8 = -<span class=hljs-number >280.0</span>*y6*y8 + <span class=hljs-number >1.81</span>*y7
  SA[dy1,dy2,dy3,dy4,dy5,dy6,dy7,dy8]
<span class=hljs-keyword >end</span>

u0 = SA[<span class=hljs-number >1</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0</span>,<span class=hljs-number >0.0057</span>]
prob = ODEProblem(hires,u0,(<span class=hljs-number >0.0</span>,<span class=hljs-number >321.8122</span>))
<span class=hljs-comment ># Defaults to reltol=1e-3, abstol=1e-6</span>
<span class=hljs-meta >@btime</span> sol = solve(prob,Rosenbrock23(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >8</span>}()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-meta >@btime</span> sol = solve(prob,Rodas5(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >8</span>}()),save_everystep=<span class=hljs-literal >false</span>)

<span class=hljs-comment ># Before:</span>
<span class=hljs-number >128.000</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >6.36</span> KiB)
<span class=hljs-number >144.600</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >7.61</span> KiB)

<span class=hljs-comment ># Now</span>
<span class=hljs-number >88.800</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >8.14</span> KiB)
<span class=hljs-number >66.900</span> μs (<span class=hljs-number >26</span> allocations: <span class=hljs-number >9.22</span> KiB)

<span class=hljs-keyword >using</span> OrdinaryDiffEq, StaticArrays, BenchmarkTools
<span class=hljs-keyword >const</span> k1=<span class=hljs-number >.35e0</span>; <span class=hljs-keyword >const</span> k2=<span class=hljs-number >.266e2</span>; <span class=hljs-keyword >const</span> k3=<span class=hljs-number >.123e5</span>
<span class=hljs-keyword >const</span> k4=<span class=hljs-number >.86e-3</span>; <span class=hljs-keyword >const</span> k5=<span class=hljs-number >.82e-3</span>; <span class=hljs-keyword >const</span> k6=<span class=hljs-number >.15e5</span>
<span class=hljs-keyword >const</span> k7=<span class=hljs-number >.13e-3</span>; <span class=hljs-keyword >const</span> k8=<span class=hljs-number >.24e5</span>; <span class=hljs-keyword >const</span> k9=<span class=hljs-number >.165e5</span>
<span class=hljs-keyword >const</span> k10=<span class=hljs-number >.9e4</span>; <span class=hljs-keyword >const</span> k11=<span class=hljs-number >.22e-1</span>; <span class=hljs-keyword >const</span> k12=<span class=hljs-number >.12e5</span>
<span class=hljs-keyword >const</span> k13=<span class=hljs-number >.188e1</span>; <span class=hljs-keyword >const</span> k14=<span class=hljs-number >.163e5</span>; <span class=hljs-keyword >const</span> k15=<span class=hljs-number >.48e7</span>
<span class=hljs-keyword >const</span> k16=<span class=hljs-number >.35e-3</span>; <span class=hljs-keyword >const</span> k17=<span class=hljs-number >.175e-1</span>; <span class=hljs-keyword >const</span> k18=<span class=hljs-number >.1e9</span>
<span class=hljs-keyword >const</span> k19=<span class=hljs-number >.444e12</span>; <span class=hljs-keyword >const</span> k20=<span class=hljs-number >.124e4</span>; <span class=hljs-keyword >const</span> k21=<span class=hljs-number >.21e1</span>
<span class=hljs-keyword >const</span> k22=<span class=hljs-number >.578e1</span>; <span class=hljs-keyword >const</span> k23=<span class=hljs-number >.474e-1</span>; <span class=hljs-keyword >const</span> k24=<span class=hljs-number >.178e4</span>
<span class=hljs-keyword >const</span> k25=<span class=hljs-number >.312e1</span>

<span class=hljs-keyword >function</span> f(y,p,t)
 r1  = k1 *y[<span class=hljs-number >1</span>]; r2  = k2 *y[<span class=hljs-number >2</span>]*y[<span class=hljs-number >4</span>]; r3  = k3 *y[<span class=hljs-number >5</span>]*y[<span class=hljs-number >2</span>]
 r4  = k4 *y[<span class=hljs-number >7</span>]; r5  = k5 *y[<span class=hljs-number >7</span>]; r6  = k6 *y[<span class=hljs-number >7</span>]*y[<span class=hljs-number >6</span>]
 r7  = k7 *y[<span class=hljs-number >9</span>]; r8  = k8 *y[<span class=hljs-number >9</span>]*y[<span class=hljs-number >6</span>]; r9  = k9 *y[<span class=hljs-number >11</span>]*y[<span class=hljs-number >2</span>]
 r10 = k10*y[<span class=hljs-number >11</span>]*y[<span class=hljs-number >1</span>]; r11 = k11*y[<span class=hljs-number >13</span>]; r12 = k12*y[<span class=hljs-number >10</span>]*y[<span class=hljs-number >2</span>]
 r13 = k13*y[<span class=hljs-number >14</span>]; r14 = k14*y[<span class=hljs-number >1</span>]*y[<span class=hljs-number >6</span>]; r15 = k15*y[<span class=hljs-number >3</span>]
 r16 = k16*y[<span class=hljs-number >4</span>]; r17 = k17*y[<span class=hljs-number >4</span>]; r18 = k18*y[<span class=hljs-number >16</span>]; r19 = k19*y[<span class=hljs-number >16</span>]
 r20 = k20*y[<span class=hljs-number >17</span>]*y[<span class=hljs-number >6</span>]; r21 = k21*y[<span class=hljs-number >19</span>]; r22 = k22*y[<span class=hljs-number >19</span>]
 r23 = k23*y[<span class=hljs-number >1</span>]*y[<span class=hljs-number >4</span>]; r24 = k24*y[<span class=hljs-number >19</span>]*y[<span class=hljs-number >1</span>]; r25 = k25*y[<span class=hljs-number >20</span>]

 dy1  = -r1-r10-r14-r23-r24+
          r2+r3+r9+r11+r12+r22+r25; dy2  = -r2-r3-r9-r12+r1+r21
 dy3  = -r15+r1+r17+r19+r22; dy4  = -r2-r16-r17-r23+r15
 dy5  = -r3+r4+r4+r6+r7+r13+r20; dy6  = -r6-r8-r14-r20+r3+r18+r18
 dy7  = -r4-r5-r6+r13; dy8  = r4+r5+r6+r7
 dy9  = -r7-r8; dy10 = -r12+r7+r9; dy11 = -r9-r10+r8+r11
 dy12 = r9; dy13 = -r11+r10; dy14 = -r13+r12
 dy15 = r14; dy16 = -r18-r19+r16; dy17 = -r20; dy18 = r20
 dy19 = -r21-r22-r24+r23+r25; dy20 = -r25+r24
 SA[dy1,dy2,dy3,dy4,dy5,dy6,dy7,dy8,dy9,dy10,dy11,dy12,dy13,dy14,dy15,dy16,dy17,dy18,dy19,dy20]
<span class=hljs-keyword >end</span>

u0 = zeros(<span class=hljs-number >20</span>); u0[<span class=hljs-number >2</span>]  = <span class=hljs-number >0.2</span>; u0[<span class=hljs-number >4</span>]  = <span class=hljs-number >0.04</span>; u0[<span class=hljs-number >7</span>]  = <span class=hljs-number >0.1</span>; u0[<span class=hljs-number >8</span>]  = <span class=hljs-number >0.3</span>
u0[<span class=hljs-number >9</span>]  = <span class=hljs-number >0.01</span>; u0[<span class=hljs-number >17</span>] = <span class=hljs-number >0.007</span>; u0 = SA[u0...]
prob = ODEProblem(f,u0,(<span class=hljs-number >0.0</span>,<span class=hljs-number >60.0</span>))
<span class=hljs-meta >@btime</span> sol = solve(prob,Rosenbrock23(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >8</span>}()),save_everystep=<span class=hljs-literal >false</span>)
<span class=hljs-meta >@btime</span> sol = solve(prob,Rodas5(chunk_size = <span class=hljs-built_in >Val</span>{<span class=hljs-number >8</span>}()),save_everystep=<span class=hljs-literal >false</span>)

<span class=hljs-comment ># Before:</span>
<span class=hljs-number >12.170</span> ms (<span class=hljs-number >482</span> allocations: <span class=hljs-number >814.94</span> KiB)
<span class=hljs-number >23.892</span> ms (<span class=hljs-number >922</span> allocations: <span class=hljs-number >1.54</span> MiB)

<span class=hljs-comment ># Now</span>
<span class=hljs-number >3.823</span> ms (<span class=hljs-number >672</span> allocations: <span class=hljs-number >405.56</span> KiB)
<span class=hljs-number >2.813</span> ms (<span class=hljs-number >1678</span> allocations: <span class=hljs-number >566.19</span> KiB)</code></pre>
<h2 id=differential-algebraic_equation_dae_solver_benchmarks ><a href="#differential-algebraic_equation_dae_solver_benchmarks" class=header-anchor >Differential-Algebraic Equation &#40;DAE&#41; Solver Benchmarks</a></h2>
<p>Finally and at last: DAE benchmarks have been added to <a href="https://github.com/SciML/SciMLBenchmarks.jl">SciMLBenchmarks.jl&#33;</a> What held us up is that we wanted everything: we wanted to test mass-matrix ODE solvers against fully implicit DAE solvers vs methods which embed the constraints. Given the advancements in <a href="https://mtk.sciml.ai/dev/">ModelingToolkit.jl</a>, we were able to build a code that automatically generates all forms.</p>
<p>Right now we only have a few smaller DAEs implemented, but so far across the board the OrdinaryDiffEq.jl algorithms are outperforming Sundials IDA and DASKR.</p>
<p>Chemical Akzo Nobel:</p>
<p><img src="https://user-images.githubusercontent.com/1814174/148871710-c8a22786-3342-46fd-a339-cfe30daa4e9e.png" alt="" /></p>
<p>Orego DAE:</p>
<p><img src="https://user-images.githubusercontent.com/1814174/148871713-10ae670c-6fbf-4efd-b948-69c80def80a9.png" alt="" /></p>
<p>ROBER DAE:</p>
<p><img src="https://user-images.githubusercontent.com/1814174/148871714-7acfc788-7099-4988-bf16-84116de13cf1.png" alt="" /></p>
<p>We will continue to expand the suite, and are looking for <a href="https://github.com/SciML/SciMLBenchmarks.jl/issues/359">anyone interested in helping out&#33;</a></p>
<h2 id=new_documentation_tutorial_on_code_optimization_for_differentialequations ><a href="#new_documentation_tutorial_on_code_optimization_for_differentialequations" class=header-anchor >New Documentation Tutorial on Code Optimization for DifferentialEquations</a></h2>
<p>Everyone needs help optimizing their code. Now there is <a href="https://diffeq.sciml.ai/stable/tutorials/faster_ode_example/">a new tutorial in the DifferentialEquations.jl documentation</a> which goes through non-stiff and stiff ODE codes, showing users how to optimize their code.</p>
<h2 id=greatly_improved_startup_times ><a href="#greatly_improved_startup_times" class=header-anchor >Greatly Improved Startup Times</a></h2>
<p>If you haven&#39;t been following <a href="https://github.com/SciML/DifferentialEquations.jl/issues/786">the big compile time issue</a>, you may have still noticed that things have gotten a lot snappier. We got some very early wins. For example, with non-stiff ODEs, compile times went from almost 5 seconds to about 0.88 seconds:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq, SnoopCompile

<span class=hljs-keyword >function</span> lorenz(du,u,p,t)
 du[<span class=hljs-number >1</span>] = <span class=hljs-number >10.0</span>(u[<span class=hljs-number >2</span>]-u[<span class=hljs-number >1</span>])
 du[<span class=hljs-number >2</span>] = u[<span class=hljs-number >1</span>]*(<span class=hljs-number >28.0</span>-u[<span class=hljs-number >3</span>]) - u[<span class=hljs-number >2</span>]
 du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>] - (<span class=hljs-number >8</span>/<span class=hljs-number >3</span>)*u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>

u0 = [<span class=hljs-number >1.0</span>;<span class=hljs-number >0.0</span>;<span class=hljs-number >0.0</span>]
tspan = (<span class=hljs-number >0.0</span>,<span class=hljs-number >100.0</span>)
prob = ODEProblem(lorenz,u0,tspan)
alg = Tsit5()
tinf = <span class=hljs-meta >@snoopi_deep</span> solve(prob,alg)

<span class=hljs-comment ># OrdinaryDiffEq v5.60.2</span>
<span class=hljs-comment ># InferenceTimingNode: 1.249748/4.881587 on Core.Compiler.Timings.ROOT() with 2 direct children</span>

<span class=hljs-comment ># Now</span>
<span class=hljs-comment ># InferenceTimingNode: 0.634172/0.875295 on Core.Compiler.Timings.ROOT() with 1 direct children</span></code></pre>
<p>For stiff ODEs, we went from 17 seconds to 3 seconds:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> lorenz(du,u,p,t)
 du[<span class=hljs-number >1</span>] = <span class=hljs-number >10.0</span>(u[<span class=hljs-number >2</span>]-u[<span class=hljs-number >1</span>])
 du[<span class=hljs-number >2</span>] = u[<span class=hljs-number >1</span>]*(<span class=hljs-number >28.0</span>-u[<span class=hljs-number >3</span>]) - u[<span class=hljs-number >2</span>]
 du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>] - (<span class=hljs-number >8</span>/<span class=hljs-number >3</span>)*u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>

u0 = [<span class=hljs-number >1.0</span>;<span class=hljs-number >0.0</span>;<span class=hljs-number >0.0</span>]
tspan = (<span class=hljs-number >0.0</span>,<span class=hljs-number >100.0</span>)

<span class=hljs-keyword >using</span> OrdinaryDiffEq, SnoopCompile
prob = ODEProblem(lorenz,u0,tspan)

alg = Rodas5()
tinf = <span class=hljs-meta >@snoopi_deep</span> solve(prob,alg)

<span class=hljs-comment ># Before:</span>
<span class=hljs-comment ># InferenceTimingNode: 1.460777/16.030597 on Core.Compiler.Timings.ROOT() with 46 direct children</span>

<span class=hljs-comment ># After:</span>
<span class=hljs-comment ># InferenceTimingNode: 1.077774/2.868269 on Core.Compiler.Timings.ROOT() with 11 direct children</span></code></pre>
<p>We fixed issues that invalidated the precompilation improvements with downstream libraries. We even improved compilation times with respect to automatic differentiation:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq, SnoopCompile, ForwardDiff

lorenz = (du,u,p,t) -&gt; <span class=hljs-keyword >begin</span>
        du[<span class=hljs-number >1</span>] = <span class=hljs-number >10.0</span>(u[<span class=hljs-number >2</span>]-u[<span class=hljs-number >1</span>])
        du[<span class=hljs-number >2</span>] = u[<span class=hljs-number >1</span>]*(<span class=hljs-number >28.0</span>-u[<span class=hljs-number >3</span>]) - u[<span class=hljs-number >2</span>]
        du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >1</span>]*u[<span class=hljs-number >2</span>] - (<span class=hljs-number >8</span>/<span class=hljs-number >3</span>)*u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>

u0 = [<span class=hljs-number >1.0</span>;<span class=hljs-number >0.0</span>;<span class=hljs-number >0.0</span>]; tspan = (<span class=hljs-number >0.0</span>,<span class=hljs-number >100.0</span>);
prob = ODEProblem(lorenz,u0,tspan); alg = Rodas5();
tinf = <span class=hljs-meta >@snoopi_deep</span> ForwardDiff.gradient(u0 -&gt; sum(solve(ODEProblem(lorenz,u0,tspan),alg)), u0)
tinf = <span class=hljs-meta >@snoopi_deep</span> ForwardDiff.gradient(u0 -&gt; sum(solve(ODEProblem(lorenz,u0,tspan),alg)), u0)

<span class=hljs-comment ># Before:</span>
<span class=hljs-comment ># First</span>
<span class=hljs-comment ># InferenceTimingNode: 1.849625/14.538148 on Core.Compiler.Timings.ROOT() with 32 direct children</span>
<span class=hljs-comment ># Second</span>
<span class=hljs-comment ># InferenceTimingNode: 1.531660/4.170409 on Core.Compiler.Timings.ROOT() with 12 direct children</span>

<span class=hljs-comment ># After:</span>
<span class=hljs-comment ># First</span>
<span class=hljs-comment ># InferenceTimingNode: 1.181086/3.320321 on Core.Compiler.Timings.ROOT() with 32 direct children</span>
<span class=hljs-comment ># Second</span>
<span class=hljs-comment ># InferenceTimingNode: 0.998814/1.650488 on Core.Compiler.Timings.ROOT() with 11 direct children</span></code></pre>
<p>Across the board most DifferentialEquations.jl usage should be a heck of a lot snappier.</p>
<h2 id=integro-differential_equations_with_neuralpdejl ><a href="#integro-differential_equations_with_neuralpdejl" class=header-anchor >Integro-Differential Equations with NeuralPDE.jl</a></h2>
<p>The <a href="https://neuralpde.sciml.ai/dev/">NeuralPDE.jl Physics-Informed Neural Network library</a> now supports the automated solution of <a href="https://en.wikipedia.org/wiki/Integro-differential_equation">integro-differential equations</a>.</p>
<p>For example, from a pure symbolic description of a PDE with integrals defined in there:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> NeuralPDE, Flux, ModelingToolkit, GalacticOptim, Optim, DiffEqFlux, DomainSets
<span class=hljs-keyword >import</span> ModelingToolkit: Interval, infimum, supremum

<span class=hljs-meta >@parameters</span> t
<span class=hljs-meta >@variables</span> i(..)
Di = Differential(t)
Ii = Integral(t <span class=hljs-keyword >in</span> DomainSets.ClosedInterval(<span class=hljs-number >0</span>, t))
eq = Di(i(t)) + <span class=hljs-number >2</span>*i(t) + <span class=hljs-number >5</span>*Ii(i(t)) ~ <span class=hljs-number >1</span>
bcs = [i(<span class=hljs-number >0.</span>) ~ <span class=hljs-number >0.0</span>]
domains = [t ∈ Interval(<span class=hljs-number >0.0</span>,<span class=hljs-number >2.0</span>)]</code></pre>
<p>we can ask the system to generate a neural network representing its solution:</p>
<pre><code class="julia hljs">chain = Chain(Dense(<span class=hljs-number >1</span>,<span class=hljs-number >15</span>,Flux.σ),Dense(<span class=hljs-number >15</span>,<span class=hljs-number >1</span>))
initθ = <span class=hljs-built_in >Float64</span>.(DiffEqFlux.initial_params(chain))

strategy_ = GridTraining(<span class=hljs-number >0.05</span>)
discretization = PhysicsInformedNN(chain,
                                   strategy_;
                                   init_params = <span class=hljs-literal >nothing</span>,
                                   phi = <span class=hljs-literal >nothing</span>,
                                   derivative = <span class=hljs-literal >nothing</span>)
<span class=hljs-meta >@named</span> pde_system = PDESystem(eq,bcs,domains,[t],[i(t)])
prob = NeuralPDE.discretize(pde_system,discretization)
cb = <span class=hljs-keyword >function</span> (p,l)
    println(<span class=hljs-string >&quot;Current loss is: <span class=hljs-variable >$l</span>&quot;</span>)
    <span class=hljs-keyword >return</span> <span class=hljs-literal >false</span>
<span class=hljs-keyword >end</span>
res = GalacticOptim.solve(prob, BFGS(); cb = cb, maxiters=<span class=hljs-number >100</span>)</code></pre>
<h2 id=other_and_upcoming_updates ><a href="#other_and_upcoming_updates" class=header-anchor >Other and Upcoming Updates</a></h2>
<p>There are many other updates to be aware of which we will highlight in future news posts. As a quick overview:</p>
<ul>
<li><p>Massive improvements to ModelingToolkit.jl with mixed discrete&#43;continuous system handling.</p>

<li><p>GalacticOptim.jl received some major improvements and overhauled documentation over the last round. It now wraps nearly 100 optimization methods from 13 libraries into its common interface.</p>

<li><p>ExponentialUtilities.jl received a new <code>exponential&#33;</code> method with greatly improved matrix exponential performance over Julia&#39;s Base.</p>

<li><p>PreallocationTools.jl received many cosmetic updates to be easier to use.</p>

<li><p>Many performance improvements to DiffEqSensitivity.jl and DiffEqFlux.jl</p>

<li><p>The new library StructuralIdentifiability.jl for computing the structural identifiability of parameters in ODE models will be announced in the next round. A few issues are still being worked out over the next month.</p>

<li><p>The new library MethodOfLines.jl for automating method of lines discretizations will be announced shortly. Currently it&#39;s in a beta mode.</p>

<li><p>The new library ModelingToolkitStandardLibrary.jl has been created. This will in a beta mode for a bit longer as it fleshes out its offering.</p>

<li><p>SymbolicNumericIntegration.jl was released and will be included in the next release notes.</p>

<li><p>MinimallyDisruptiveCurves.jl was released and will be included in the next release notes.</p>

</ul>
<!-- Footer-->
<footer class="footer bg-light">
  <div class=container >
      <div class=row >
          <div class="col-lg-6 h-100 text-center text-lg-start my-auto">
              <ul class="list-inline mb-2">
                  
                  <li class=list-inline-item ><a href="/community">Contact</a>
                  <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a>
                  <li class=list-inline-item ><a href="#!">Privacy Policy</a> -->
              </ul>
              <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p>
              <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p>

            </div>
          <div class="col-lg-6 h-100 text-center text-lg-end my-auto">
              <ul class="list-inline mb-0">
                  <li class="list-inline-item me-4">
                      <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a>
                  
                  <li class="list-inline-item me-4">
                      <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a>
                  
                  <li class=list-inline-item >
                      <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a>
                  
              </ul>
          </div>
      </div>
  </div>
</footer>
</div>