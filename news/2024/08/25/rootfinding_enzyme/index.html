<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <meta property="og:title" content="SciML: Open Source Software for Scientific Machine Learning"> <meta property="og:description" content="Open Source Software for Scientific Machine Learning"> <meta property="og:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta property="og:url" content="https://sciml.ai"> <meta name="twitter:title" content=SciML > <meta name="twitter:description" content="Open Source Software for Scientific Machine Learning"> <meta name="twitter:image" content="https://sciml.ai/assets/SciMLGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <!-- Favicon--> <link rel=icon  type="image/x-icon" href="assets/favicon.png" /> <!-- Bootstrap icons--> <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css" rel=stylesheet  type="text/css" /> <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css"> <!-- Google fonts--> <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel=stylesheet  type="text/css" /> <!-- Core theme CSS (includes Bootstrap)--> <link href="./css/styles.css" rel=stylesheet  /> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/styles.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-90474609-2'); </script> <title>SciML Update: Symbolic Solvers, Direct Enzyme on ODEs, and More</title> <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.3/dist/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin=anonymous ></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin=anonymous ></script> <div class=container-fluid  id=top-alert > <div class="alert alert-dark alert-dismissible mb-0" role=alert > <p class=text-center > <a href="https://youtu.be/yHiyJQdWBY8">Check out the latest talk: "The Continuing Advancements of Scientific Machine Learning (SciML)"</a> </p> <!-- <button type=button  class=close  data-dismiss=alert  aria-label=Close > <span aria-hidden=true >&times;</span> --> </button> </div> </div> <header> <nav class="navbar navbar-expand-lg navbar-light"> <a class=navbar-brand  href="/">Home</a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class="nav-item active"> <a class=nav-link  href="https://docs.sciml.ai/">Documentation</a> <li class=nav-item > <a class=nav-link  href="/news/">News</a> <li class=nav-item > <a class=nav-link  href="/roadmap/">Roadmap</a> <li class=nav-item > <a class=nav-link  href="/citing/">Citing</a> <li class=nav-item > <a class=nav-link  href="/showcase/">Showcase</a> <li class=nav-item > <a class=nav-link  href="https://benchmarks.sciml.ai/">Benchmarks</a> <li class=nav-item > <a class=nav-link  href="https://github.com/SciML/">GitHub</a> <li class="nav-item dropdown"> <a class="nav-link dropdown-toggle" href="#" id=navbarDropdownMenuLink  role=button  data-toggle=dropdown  aria-haspopup=true  aria-expanded=false > Community </a> <div class=dropdown-menu  aria-labelledby=navbarDropdownMenuLink > <a class=dropdown-item  href="/community/">Community Home</a> <a class=dropdown-item  href="/governance/">Governance</a> <a class=dropdown-item  href="/challenge/">Challenges</a> <a class=dropdown-item  href="/dev/">Developer Programs</a> </div> <li class=nav-item > <a class=nav-link  href="https://juliahub.com/company/contact-us-sciml"> Commercial Support </a> <li class=nav-item > <a class=nav-link  href="https://numfocus.org/donate-to-sciml"><i class="bi bi-heart"></i> Donate</a> </ul> </div> </nav> </header> <div class=franklin-content ><h1 id=sciml_update_symbolic_solvers_direct_enzyme_on_odes_and_more ><a href="#sciml_update_symbolic_solvers_direct_enzyme_on_odes_and_more" class=header-anchor >SciML Update: Symbolic Solvers, Direct Enzyme on ODEs, and More</a></h1> <p>In this SciML update we have plenty of new features to check out including new symbolic solvers, direct Enzyme support on OrdinaryDiffEq.jl, and major loading improvements across the ecosystem. Time for the fun details&#33;</p> <h2 id=symbolic_solvers_solve_systems_of_equations_symbolically_with_symbolicsjl ><a href="#symbolic_solvers_solve_systems_of_equations_symbolically_with_symbolicsjl" class=header-anchor >Symbolic Solvers: Solve Systems of Equations Symbolically with Symbolics.jl</a></h2> <p>A long-time requested feature for Symbolics.jl has been to add symbolic solvers. This is functionality to say give a system like <code>x^2 - y &#61; 5, sin&#40;y&#41; &#43; cos&#40;x&#41; &#61; 2</code>, and let it spit out a symbolic exact solution. Well with this release it&#39;s finally here&#33; Thanks to a Google Summer of Code project by Yassin ElBedwihy, the <a href="https://github.com/JuliaSymbolics/Symbolics.jl/pull/1192">core pull-request adding the symbolic solver</a> has finally landed. With this PR, you can do things like:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Symbolics, Groebner
<span class=hljs-meta >@variables</span> x y z;
eqs = [x^<span class=hljs-number >2</span> + y + z - <span class=hljs-number >1</span>, x + y^<span class=hljs-number >2</span> + z - <span class=hljs-number >1</span>, x + y + z^<span class=hljs-number >2</span> - <span class=hljs-number >1</span>]
Symbolics.symbolic_solve(eqs, [x,y,z])</code></pre> <p>and get the symbolic solution to the set of polynomial equations. Want to know the answer to the above? Well install it and find it&#33;</p> <p>It comes complete with extensions that make use of the <a href="https://github.com/Nemocas/Nemo.jl">Nemo</a> Computer Algebra System &#40;CAS&#41;, which is an abstract algebra system developed by other smart Julia developers that specializes in &quot;abstract algebra&quot; like computational group theory, computational ring theory, and more. It mixes some of these techniques in with rule-based techniques to give a solver that is &quot;best of both worlds&quot; and is easily extendable with other submodules. For Groebner basis calculations, it uses the <a href="https://github.com/sumiya11/Groebner.jl">Groebner.jl</a> package which is <a href="https://arxiv.org/abs/2304.06935">demonstrated to be one of the most efficient implementations</a> and thus serves as a solid building block.</p> <p>In more detail, The <code>symbolic_solve</code> function uses 4 hidden solvers in order to solve the user&#39;s input. Its base, <code>solve_univar</code>, uses analytic solutions up to polynomials of degree 4 and factoring as its method for solving univariate polynomials. The function&#39;s <code>solve_multipoly</code> uses GCD on the input polynomials then throws passes the result to <code>solve_univar</code>. The function&#39;s <code>solve_multivar</code> uses Groebner basis and a separating form in order to create linear equations in the input variables and a single high degree equation in the separating variable. Each equation resulting from the basis is then passed to <code>solve_univar</code>. We can see that essentially, <code>solve_univar</code> is the building block of <code>symbolic_solve</code>. If the input is not a valid polynomial and can not be solved by the algorithm above, <code>symbolic_solve</code> passes it to <code>ia_solve</code>, which attempts solving by attraction and isolation. This only works when the input is a single expression and the user wants the answer in terms of a single variable. Say <code>log&#40;x&#41; - a &#61;&#61; 0</code> gives us <code>&#91;e^a&#93;</code>. This attraction isolation is then extendable via rules, so down the line we can add extensions to handle cases like LambertW.jl and SpecialFunctions.jl detection.</p> <p>Its current feature completeness can be summarized as:</p> <ul> <li><p>&#91;x&#93; Linear and polynomial equations</p> <li><p>&#91;x&#93; Systems of linear and polynomial equations</p> <li><p>&#91;x&#93; Some transcendental functions</p> <li><p>&#91;x&#93; Systems of linear equations with parameters &#40;via <code>symbolic_linear_solve</code>&#41;</p> <li><p>&#91; &#93; Systems of polynomial equations with parameters</p> <li><p>&#91; &#93; Inequalities</p> <li><p>&#91; &#93; Differential Equations &#40;ODEs&#41;</p> <li><p>&#91; &#93; Integrals</p> </ul> <p>With plans to continue developing and handle the next cases soon after.</p> <h2 id=symbolics_v6_symbolicutils_v3_terminterface_v2_core_interface_improvements ><a href="#symbolics_v6_symbolicutils_v3_terminterface_v2_core_interface_improvements" class=header-anchor >Symbolics v6 / SymbolicUtils v3 / TermInterface v2: Core Interface Improvements</a></h2> <p>A major was released on the Symbolics stack this month, signifying a breaking change. The major breaking change here is the re-adoption of <a href="https://github.com/JuliaSymbolics/TermInterface.jl">TermInterface.jl</a>, which is a core interface for symbolic terms. By having all symbolic libraries extend term interface, be it Metatheory.jl, Symbolics.jl, SymPy.jl, and more, the core interface gives a common specification for building and translating terms, making all of them interopable. This means that by re-adopting TermInterface, we now have bidirectional translation to and from SymPy as a well-maintained part of the interfaces, and moving between rule-based approaches and E-graphs based approaches is a standard part of the interfaces.</p> <p>At the same time that we tacked TermInterface v2, we also tackled some of the long-standing problems in the Symbolics ecosystem. In particular, for a symbolic term like <code>ex &#61; f&#40;x,y&#41;</code>, while <code>arguments&#40;ex&#41; &#61;&#61; &#91;x,y&#93;</code>, if you build a symbolic expression of <code>ex &#61; x &#43; y &#43; z</code> the internal data structures can be optimized by assuming no ordering in such a commutative operation. However before we guarenteed argument order on <code>arguments&#40;ex&#41;</code>, so then <code>arguments&#40;ex&#41; &#61; &#91;x,y,z&#93;</code> was enforced to always be sorted lexicographically. However, it turns out that after building out the symbolic stack that this choice is one of the most costly in the entire ecosystem&#33; Thus we have changed <code>arguments&#40;ex&#41;</code> to not guarantee a sorting order, allowing symbolic manipulations which specialize on commutativity to skip spending 99&#37; of their time calculating lexicographic sorts. In order to allow for printing in a stable manner, we created the new interface functions such as <code>sorted_arguments&#40;ex&#41;</code> which guarantee a sorting and thus take the performance hit, and this is used so that things like Latex outputs and displays are more stable.</p> <p>Another major change was a breaking change to the <code>maketerm</code> syntax to remove the <code>symtype</code> argument. While symbolic terms like those in Symbolics.jl can still be typed, i.e. <code>@variables x::Complex</code> which changes their behavior in things like simplification rules, this information is now captured in the metadata instead of the term itself. This unifies more of the implementation between Symbolics.jl and Metatheory.jl to better allow usage of E-graphs on symbolic terms. </p> <p>SymbolicUtils.jl v3 and Symboilcs v6 thus take these interface changes as their breaking bits. Most code should actually not be broken by these changes, we only had to update the code of approximately 10&#37; of the upstream libraries to allow for this change, and many of those only because we the symbolics developers are using some deeper features. So it&#39;s generally a small break but we get some major performance improvements and nice new features that unify the ecosystem.</p> <p>We had a few major Symbolics.jl updates, with this year having Symbolics v4, v5, and now v6, a few with SymbolicUtils, and new a few with TermInterface. We are happy to report that we believe TermInterface.jl is now finally stable, so these updates should have reached their conclusion. There is a common core change to SymbolicUtils.jl which should be a major performance improvement by changing the structure of the BasicSymbolic, however we believe this is likely to be non-breaking. Thus the 2023-2024 stream of majors on Symbolics seems to have come to its end and Symbolics is now in more of a feature building phase.</p> <h2 id=direct_ode_support_with_enzyme ><a href="#direct_ode_support_with_enzyme" class=header-anchor >Direct ODE Support with Enzyme</a></h2> <p>There are two kinds of adjoints, one is the continuous adjoint approaches which define a new ODE problem to solve, and another which uses automatic differentiation directly through the solver. There are pros and cons of each, as described in <a href="https://arxiv.org/abs/2406.09699">our recent review on differentiation of ODEs</a> in exquisite detail. </p> <p>However, improving support for both is always on the menu. With discrete adjoints, AD support directly through the solver has been supported by ForwardDiff, ReverseDiff, and Tracker since almost the dawn of DifferentialEquations.jl. Limited support for Zygote through specific solvers, such as those in SimpleDiffEq.jl, has also always existed as well. But Enzyme is a much more powerful system. We have used it rather extensively in the continuous adjoint infrastructure for almost half a decade now, but it always lacked the capability to directly differentiate the complexity of the ODE solvers...</p> <p>Until now. As part of the JuliaCon 2024 Hackathon, the remaining issues were worked through and now the explicit methods in OrdinaryDiffEq.jl can be directly differentiated with Enzyme. This can be seen by using the AD passthrough setting to avoid the SciMLSensitivity adjoint catching as follows:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Enzyme, OrdinaryDiffEq, StaticArrays

<span class=hljs-keyword >function</span> lorenz!(du, u, p, t)
    du[<span class=hljs-number >1</span>] = <span class=hljs-number >10.0</span>(u[<span class=hljs-number >2</span>] - u[<span class=hljs-number >1</span>])
    du[<span class=hljs-number >2</span>] = u[<span class=hljs-number >1</span>] * (<span class=hljs-number >28.0</span> - u[<span class=hljs-number >3</span>]) - u[<span class=hljs-number >2</span>]
    du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >1</span>] * u[<span class=hljs-number >2</span>] - (<span class=hljs-number >8</span> / <span class=hljs-number >3</span>) * u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >const</span> _saveat =  SA[<span class=hljs-number >0.0</span>,<span class=hljs-number >0.25</span>,<span class=hljs-number >0.5</span>,<span class=hljs-number >0.75</span>,<span class=hljs-number >1.0</span>,<span class=hljs-number >1.25</span>,<span class=hljs-number >1.5</span>,<span class=hljs-number >1.75</span>,<span class=hljs-number >2.0</span>,<span class=hljs-number >2.25</span>,<span class=hljs-number >2.5</span>,<span class=hljs-number >2.75</span>,<span class=hljs-number >3.0</span>]

<span class=hljs-keyword >function</span> f(y::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>}, u0::<span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>})
    tspan = (<span class=hljs-number >0.0</span>, <span class=hljs-number >3.0</span>)
    prob = ODEProblem{<span class=hljs-literal >true</span>, SciMLBase.FullSpecialize}(lorenz!, u0, tspan)
    sol = DiffEqBase.solve(prob, Tsit5(), saveat = _saveat, sensealg = DiffEqBase.SensitivityADPassThrough())
    y .= sol[<span class=hljs-number >1</span>,:]
    <span class=hljs-keyword >return</span> <span class=hljs-literal >nothing</span>
<span class=hljs-keyword >end</span>;
u0 = [<span class=hljs-number >1.0</span>; <span class=hljs-number >0.0</span>; <span class=hljs-number >0.0</span>]
d_u0 = zeros(<span class=hljs-number >3</span>)
y  = zeros(<span class=hljs-number >13</span>)
dy = zeros(<span class=hljs-number >13</span>)

Enzyme.autodiff(Reverse, f,  Duplicated(y, dy), Duplicated(u0, d_u0));</code></pre> <p>This is a major leap forward in Enzyme support. SciMLSensitivity will soon update to include a EnzymeAdjoint option which makes use of this direct differentiation mode with automation of the process &#40;such as unwrapping of function pointers for <code>SciMLBase.FullSpecialize</code>, so more standard definitions work&#41;. There are still a few details to work through in order to get compatability with all features, in particular <a href="https://github.com/EnzymeAD/Enzyme.jl/issues/274">support for ranges is the leading issue</a>, but these are actively being worked on.</p> <p>Support for implicit methods is currently lacking in this form because Enzyme is incompatible with PreallocationTools.jl structures due to being unable to being able to prove the lack of aliasing. Thus Enzyme adjoint sensitivity support for implicit methods will directly come with the OrdinaryDiffEq v7 changes to the <code>autodiff</code> API which is planning to change from the lagacy ForwardDiff-based Jacobian interface to using DifferentiationInterface.jl for the Jacobian specification, which would then allow for Enzyme-based Jacobians and will work due to Enzyme-over-Enzyme support. This is expected over the next month as mentioned at JuliaCon.</p> <h2 id=scimlsensitivity_adjoint_support_for_general_scimlstructures_types ><a href="#scimlsensitivity_adjoint_support_for_general_scimlstructures_types" class=header-anchor >SciMLSensitivity Adjoint Support for General SciMLStructures Types</a></h2> <p>For many years SciMLSensitivity.jl only supported AbstractArray parameter types for its continuous adjoints because it required being able to solve differential equations based on the object type. This was relaxed a bit with the introduction of <code>GaussAdjoint</code> as the new standard adjoint method in 2023, but there were still limitations. Now thanks to a <a href="https://github.com/SciML/SciMLSensitivity.jl/pull/1057">massive effort by Dhariya</a>, this limitation has been lifted. Now any type which defines the <a href="https://docs.sciml.ai/SciMLStructures/stable/">SciMLStructures interface</a> for tunable canonicalization can automatically be supported.</p> <p>One major result of this is that the <code>MTKParameters</code> object from ModelingToolkit v9 is supported, which means that general adjoint differentiation is now compatible with MTK models. This includes compatability with the <a href="https://docs.sciml.ai/SymbolicIndexingInterface/stable/">SymbolicIndexingInterface</a>, meaning that lazy observed quantities can be differented with respect to, allowing all of the symbolic simplifications of MTK to be used within the context of AD.</p> <!-- Footer--> <footer class="footer bg-light"> <div class=container > <div class=row > <div class="col-lg-6 h-100 text-center text-lg-start my-auto"> <ul class="list-inline mb-2"> <li class=list-inline-item ><a href="/community">Contact</a> <!-- <li class=list-inline-item ><a href="#!">Terms of Use</a> <li class=list-inline-item ><a href="#!">Privacy Policy</a> --> </ul> <p class="text-muted small mb-4 mb-lg-0">Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. &copy; SciML 2022. All Rights Reserved.</p> <p class="text-muted small mb-4 mb-lg-0">Edit on <a href="https://github.com/SciML/sciml.ai">GitHub</a></p> </div> <div class="col-lg-6 h-100 text-center text-lg-end my-auto"> <ul class="list-inline mb-0"> <li class="list-inline-item me-4"> <a href="https://github.com/SciML"><i class="bi-github fs-3"></i></a> <li class="list-inline-item me-4"> <a href="https://twitter.com/SciML_Org"><i class="bi-twitter fs-3"></i></a> <li class=list-inline-item > <a href="https://www.linkedin.com/company/the-julia-language"><i class="bi-linkedin fs-3"></i></a> </ul> </div> </div> </div> </footer> </div>