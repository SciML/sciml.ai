<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/staging.sciml.ai/libs/highlight/github.min.css"> <link rel=stylesheet  href="/staging.sciml.ai/css/franklin.css"> <link rel=stylesheet  href="/staging.sciml.ai/css/hypertext.css"> <link rel=icon  href="/staging.sciml.ai/assets/favicon.png"> <title> DifferentialEquations.jl v6.4.0: Full GPU ODE, Performance, ModelingToolkit </title> <header> <h1><b><center>SciML</center></b></h1> <nav> | <a href="/staging.sciml.ai/" class=current >Home</a> | <a href="/staging.sciml.ai/news/">News</a> | <a href="/staging.sciml.ai/roadmap/">Roadmap</a> | <a href="/staging.sciml.ai/citing/">Citing</a> | <a href="/staging.sciml.ai/governance/">Governance</a> | <a href="/staging.sciml.ai/showcase/">Showcase</a> | <a href="/staging.sciml.ai/community/">Community</a> <hr/> | <a href="/staging.sciml.ai/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>This is a huge release. We should take the time to thank every contributor to the JuliaDiffEq package ecosystem. A lot of this release focuses on performance features. The ability to use stiff ODE solvers on the GPU, with automated tooling for matrix-free Newton-Krylov, faster broadcast, better Jacobian re-use algorithms, memory use reduction, etc. All of these combined give some pretty massive performance boosts in the area of medium to large sized highly stiff ODE systems. In addition, numerous robustness fixes have enhanced the usability of these tools, along with a few new features like an implementation of extrapolation for ODEs and the release of ModelingToolkit.jl.</p> <p>Let&#39;s start by summing up this release with an example.</p> <h3 id=comprehensive_example ><a href="#comprehensive_example">Comprehensive Example</a></h3> <p>Here&#39;s a nice showcase of DifferentialEquations.jl: Neural ODE with batching on the GPU &#40;without internal data transfers&#41; with high order adaptive implicit ODE solvers for stiff equations using matrix-free Newton-Krylov via preconditioned GMRES and trained using checkpointed adjoint equations. Few programs work directly with neural networks and allow for batching, few utilize GPUs, few have methods applicable to highly stiff equations, few allow for large stiff equations via matrix-free Newton-Krylov, and finally few have checkpointed adjoints. This is all done in a high level programming language. What does the code for this look like?</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq, Flux, DiffEqFlux, DiffEqOperators, CuArrays
x = <span class=hljs-built_in >Float32</span>[<span class=hljs-number >2.</span>; <span class=hljs-number >0.</span>]|&gt;gpu
tspan = <span class=hljs-built_in >Float32</span>.((<span class=hljs-number >0.0f0</span>,<span class=hljs-number >25.0f0</span>))
dudt = Chain(Dense(<span class=hljs-number >2</span>,<span class=hljs-number >50</span>,tanh),Dense(<span class=hljs-number >50</span>,<span class=hljs-number >2</span>))|&gt;gpu
p = DiffEqFlux.destructure(dudt)
dudt_(du,u::TrackedArray,p,t) =  du .= DiffEqFlux.restructure(dudt,p)(u)
dudt_(du,u::<span class=hljs-built_in >AbstractArray</span>,p,t) = du .= Flux.data(DiffEqFlux.restructure(dudt,p)(u))
ff = ODEFunction(dudt_,jac_prototype = JacVecOperator(dudt_,x))
prob = ODEProblem(ff,x,tspan,p)
diffeq_adjoint(p,prob,KenCarp4(linsolve=LinSolveGMRES());u0=x,
               saveat=<span class=hljs-number >0.0</span>:<span class=hljs-number >0.1</span>:<span class=hljs-number >25.0</span>,backsolve=<span class=hljs-literal >false</span>)</code></pre> <p>That is 10 lines of code, and we can continue to make it even more succinct.</p> <p>Now, onto the release highlights.</p> <h2 id=full_gpu_support_in_ode_solvers ><a href="#full_gpu_support_in_ode_solvers">Full GPU Support in ODE Solvers</a></h2> <p>Now not just the non-stiff ODE solvers but the stiff ODE solvers allow for the initial condition to be a GPUArray, with the internal methods not performing any indexing in order to allow for all computations to take place on the GPU without data transfers. This allows for expensive right-hand side calculations, like those in neural ODEs or PDE discretizations, to utilize GPU acceleration without worrying about whether the cost of data transfers will overtake the solver speed enhancements.</p> <p>While the presence of broadcast throughout the solvers might worry one about performance...</p> <h2 id=fast_diffeq-specific_broadcast ><a href="#fast_diffeq-specific_broadcast">Fast DiffEq-Specific Broadcast</a></h2> <p>Yingbo Ma &#40;@YingboMa&#41; implemented a fancy broadcast wrapper that allows for all sorts of information to be passed to the compiler in the differential equation solver&#39;s internals, making a bunch of no-aliasing and sizing assumptions that are normally not possible. These change the internals to all use a special <code>@..</code> which turns out to be faster than standard loops, and this is the magic that really enabled the GPU support to happen without performance regressions &#40;and in fact, we got some speedups from this, close to 2x in some cases&#33;&#41;</p> <h2 id=smart_linsolve_defaults_and_linsolvegmres ><a href="#smart_linsolve_defaults_and_linsolvegmres">Smart linsolve defaults and LinSolveGMRES</a></h2> <p>One of the biggest performance-based features to be released is smarter linsolve defaults. If you are using dense arrays with a standard Julia build, OpenBLAS does not perform recursive LU factorizations which we found to be suboptimal by about 5x in some cases. Thus our default linear solver now automatically detects the BLAS installation and utilizes RecursiveFactorizations.jl to give this speedup for many standard stiff ODE cases. In addition, if you passed a sparse Jacobian for the <code>jac_prototype</code>, the linear solver now automatically switches to a form that works for sparse Jacobians. If you use an <code>AbstractDiffEqOperator</code>, the default linear solver automatically switches to a Krylov subspace method &#40;GMRES&#41; and utilizes the matrix-free operator directly. Banded matrices and Jacobians on the GPU are now automatically handled as well.</p> <p>Of course, that&#39;s just the defaults, and most of this was possible before but now has just been made more accessible. In addition to these, the ability to easily switch to GMRES was added via <code>LinSolveGMRES</code>. Just add <code>linsolve &#61; LinSolveGMRES&#40;&#41;</code> to any native Julia algorithm with a swappable linear solver and it&#39;ll switch to using GMRES. In this you can pass options for preconditioners and tolerances as well. We will continue to integrate this better into our integrators as doing so will enhance the efficiency when solving large sparse systems.</p> <h2 id=automated_jv_products_via_autodifferentiation ><a href="#automated_jv_products_via_autodifferentiation">Automated J*v Products via Autodifferentiation</a></h2> <p>When using <code>GMRES</code>, one does not need to construct the full Jacobian matrix. Instead, one can simply use the directional derivatives in the direction of <code>v</code> in order to compute <code>J*v</code>. This has now been put into an operator form via <code>JacVecOperator&#40;dudt_,x&#41;</code>, so now users can directly ask for this to occur using one line. It allows for the use of autodifferentiation or numerical differentiation to calculate the <code>J*v</code>.</p> <h2 id=destats ><a href="#destats">DEStats</a></h2> <p>One of the nichest but nicest new features is DEStats. If you do <code>sol.destats</code> then you will see a load of information on how many steps were taken, how many <code>f</code> calls were done, etc. giving a broad overview of the performance of the algorithm. Thanks to Kanav Gupta &#40;@kanav99&#41; and Yingbo Ma &#40;@YingboMa&#41; for really driving this feature since it has allowed for a lot of these optimizations to be more thoroughly investigated. You can expect DiffEq development to accelerate with this information&#33;</p> <h2 id=improved_jacobian_reuse ><a href="#improved_jacobian_reuse">Improved Jacobian Reuse</a></h2> <p>One of the things which was noticed using DEStats was that the amount of Jacobians and inversions that were being calculated could be severly reduced. Yingbo Ma &#40;@YingboMa&#41; did just that, greatly increasing the performance of all implicit methods like <code>KenCarp4</code> showing cases in the 1000&#43; range where OrdinaryDiffEq&#39;s native methods outperformed Sundials CVODE_BDF. This still has plenty of room for improvement.</p> <h2 id=diffeqbiological_performance_improvements_for_large_networks_speed_and_sparsity ><a href="#diffeqbiological_performance_improvements_for_large_networks_speed_and_sparsity">DiffEqBiological performance improvements for large networks &#40;speed and sparsity&#41;</a></h2> <p>Samuel Isaacson &#40;@isaacson&#41; has been instrumental in improving DiffEqBiological.jl and its ability to handle large reaction networks. It can now parse the networks much faster and can build Jacobians which utilize sparse matrices. It pairs with his ParseRxns&#40;???&#41; library and has been a major source of large stiff test problems&#33;</p> <h2 id=partial_neural_odes_batching_and_gpu_fixes ><a href="#partial_neural_odes_batching_and_gpu_fixes">Partial Neural ODEs, Batching and GPU Fixes</a></h2> <p>We now have working examples of partial neural differential equations, which are equations which have pre-specified portions that are known while others are learnable neural networks. These also allow for batched data and GPU acceleration. Not much else to say except let your neural diffeqs go wild&#33;</p> <h2 id=low_memory_rk_optimality_and_alias_u0 ><a href="#low_memory_rk_optimality_and_alias_u0">Low Memory RK Optimality and Alias_u0</a></h2> <p>Kanav Gupta &#40;@kanav99&#41; and Hendrik Ranocha &#40;@ranocha&#41; did amazing jobs at doing memory optimizations of low-memory Runge-Kutta methods for hyperbolic or advection-dominated PDEs. Essentially these methods have a minimal number of registers which are theoretically required for the method. Kanav added some tricks to the implementation &#40;using a fun <code>&#61;</code> -&gt; <code>&#43;&#61;</code> overload idea&#41; and Henrick added the <code>alias_u0</code> argument to allow for using the passed in initial condition as one of the registers. Unit tests confirm that our implementations achieve the minimum possible number of registers, allowing for large PDE discretizations to make use of DifferentialEquations.jl without loss of memory efficiency. We hope to see this in use in some large-scale simulation software&#33;</p> <h2 id=more_robust_callbacks ><a href="#more_robust_callbacks">More Robust Callbacks</a></h2> <p>Our <code>ContinuousCallback</code> implementation now has increased robustness in double event detection, using a new strategy. Try to break it.</p> <h2 id=gbs_extrapolation ><a href="#gbs_extrapolation">GBS Extrapolation</a></h2> <p>New contributor Konstantin Althaus &#40;@AlthausKonstantin&#41; implemented midpoint extrapolation methods for ODEs using Barycentric formulas and different a daptivity behaviors. We will be investigating these methods for their parallelizability via multithreading in the context of stiff and non-stiff ODEs.</p> <h2 id=modelingtoolkitjl_release ><a href="#modelingtoolkitjl_release">ModelingToolkit.jl Release</a></h2> <p>ModelingToolkit.jl has now gotten some form of a stable release. A lot of credit goes to Harrison Grodin &#40;@HarrisonGrodin&#41;. While it has already been out there and found quite a bit of use, it has really picked up steam over the last year as a modeling framework suitable for the flexibility DifferentialEquations.jl. We hope to continue its development and add features like event handling to its IR.</p> <h2 id=sundials_jv_interface_stats_and_preconditioners ><a href="#sundials_jv_interface_stats_and_preconditioners">SUNDIALS J*v interface, stats, and preconditioners</a></h2> <p>While we are phasing out Sundials from our standard DifferentialEquations.jl practice, the Sundials.jl continues to improve as we add more features to benchmark against. Sundials&#39; J*v interface has now been exposed, so adding a DiffEqOperator to the <code>jac_prototype</code> will work with Sundials. <code>DEStats</code> is hooked up to Sundials, and now you can pass preconditioners to its internal Newton-Krylov methods.</p> <h1 id=next_directions ><a href="#next_directions">Next Directions</a></h1> <ul> <li><p>Improved nonlinear solvers for stiff SDE handling</p> <li><p>More adaptive methods for SDEs</p> <li><p>Better boundary condition handling in DiffEqOperators.jl</p> <li><p>More native implicit ODE &#40;DAE&#41; solvers</p> <li><p>Adaptivity in the MIRK BVP solvers</p> <li><p>LSODA integrator interface</p> <li><p>Improved BDF</p> </ul> </div>