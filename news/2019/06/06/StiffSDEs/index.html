<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/franklin.css"> <link rel=stylesheet  href="/css/hypertext.css"> <link rel=icon  href="/assets/favicon.png"> <title> DifferentialEquations.jl v6.5.0: Stiff SDEs, VectorContinuousCallback, Multithreaded Extrapolation </title> <header> <h1><b><center>SciML</center></b></h1> <nav> | <a href="/" class=current >Home</a> | <a href="/news/">News</a> | <a href="/roadmap/">Roadmap</a> | <a href="/citing/">Citing</a> | <a href="/governance/">Governance</a> | <a href="/showcase/">Showcase</a> | <a href="/community/">Community</a> <hr/> | <a href="/documentation/">Documentation</a> | <a href="https://benchmarks.sciml.ai/">Benchmarks</a> | <a href="https://github.com/SciML/">Source Code</a> </nav> </header> <div class=franklin-content ><p>﻿ Well, we zoomed towards this one. In this release we have a lot of very compelling new features for performance in specific domains. Large ODEs, stiff SDEs, high accuracy ODE solving, many callbacks, etc. are all specialized on and greatly improved in this PR.</p> <p>In fact, the milestone that we hit in this PR is that we now have a serious discussion about whether it&#39;s time to drop Sundials from all DifferentialEquations.jl default algorithm choices. More benchmarking is being done to confirm this, but the last domain we were having issues with, &quot;large enough ODEs&quot;, seems to now be handled as well by our native Julia Newton-Krylov methods as <code>CVODE&#40;linsolve&#61;:GMRES&#41;</code>, and thus without any compelling reasons we may switch to pure-Julia defaults in the next few months.</p> <p>With that in mind, here are the new features.</p> <h2 id=improved_newton-krylov ><a href="#improved_newton-krylov">Improved Newton-Krylov</a></h2> <p>This is the big change. Yingbo Ma &#40;@YingboMa&#41; tracked down the performance of Newton-Krylov and now our GMRES is in line with Sundials. On a very stiff ODE of ~1,200 ODEs and 25,000 terms with a sparse Jacobian &#40;our BCR network benchmark&#41;, the timings are very comparable:</p> <pre><code class="julia hljs">julia&gt; prob1 = ODEProblem(ODEFunction(rn, jac_prototype=JacVecOperator{<span class=hljs-built_in >Float64</span>}(rn, u0, p; autodiff=<span class=hljs-literal >false</span>)), u0, (<span class=hljs-number >0</span>, <span class=hljs-number >10000.</span>), p)
ODEProblem with uType <span class=hljs-built_in >Array</span>{<span class=hljs-built_in >Float64</span>,<span class=hljs-number >1</span>} and tType <span class=hljs-built_in >Float64</span>. In-place: <span class=hljs-literal >true</span>
timespan: (<span class=hljs-number >0.0</span>, <span class=hljs-number >10000.0</span>)
u0: [<span class=hljs-number >2.99718e5</span>, <span class=hljs-number >47149.2</span>, <span class=hljs-number >46979.0</span>, <span class=hljs-number >2.90771e5</span>, <span class=hljs-number >2.99981e5</span>, <span class=hljs-number >300000.0</span>, <span class=hljs-number >141.315</span>, <span class=hljs-number >0.12565</span>, <span class=hljs-number >0.404878</span>, <span class=hljs-number >140.805</span>  …  <span class=hljs-number >5.27997e-11</span>, <span class=hljs-number >1.00559e-24</span>, <span class=hljs-number >6.72495e-17</span>, <span class=hljs-number >3.39556e-16</span>, <span class=hljs-number >1.78799e-5</span>, <span class=hljs-number >8.76184e-13</span>, <span class=hljs-number >0.000251795</span>, <span class=hljs-number >0.000553912</span>, <span class=hljs-number >2.28125e-14</span>, <span class=hljs-number >1.78232e-8</span>]

julia&gt; sol = <span class=hljs-meta >@time</span> solve(prob1, TRBDF2(autodiff=<span class=hljs-literal >false</span>, controller=:PI, smooth_est=<span class=hljs-literal >false</span>));
 <span class=hljs-number >26.327145</span> seconds (<span class=hljs-number >5.40</span> M allocations: <span class=hljs-number >502.873</span> MiB)

julia&gt; bdf = <span class=hljs-meta >@time</span> solve(prob1, CVODE_BDF(linear_solver=:GMRES));
 <span class=hljs-number >25.688197</span> seconds (<span class=hljs-number >2.19</span> M allocations: <span class=hljs-number >525.980</span> MiB, <span class=hljs-number >4.34</span>% gc time)</code></pre> <p>We&#39;ll be verifying this on all of our PDE MOL benchmarks as well. If this has consistent results, the next release of DifferentialEquations.jl will have some changes in the default algorithms used, and DifferentialEquations.jl 7.0 will drop Sundials.jl as a dependency to be a pure-Julia library. Sundials.jl will continue to be maintained as a component solver, but this will allow us to not require any binaries in the installation of DifferentialEquations.jl, meaning you could take the pure Julia package scripts, copy paste them anywhere that Julia is installed, and they should work.</p> <h2 id=vectorcontinuouscallback ><a href="#vectorcontinuouscallback">VectorContinuousCallback</a></h2> <p>VectorContinuousCallback allows you to specify a whole array of simultaneous continuous callbacks. For example, if you have 3,000 events that you want to run, using a CallbackSet of 3,000 ContinuousCallbacks is not a good idea for performance, but VectorContinuousCallback is a fix for this use case. We plan for this to be used in cases like Modia.jl and ModelingToolkit.jl where many events need to be simultaneously checked. Thanks to Kanav Gupta &#40;@kanav99&#41; for this new feature&#33;</p> <p>For reference, here&#39;s a ball bouncing off of two walls with one callback:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> OrdinaryDiffEq, Plots
<span class=hljs-keyword >function</span> f(du,u,p,t)
  du[<span class=hljs-number >1</span>] = u[<span class=hljs-number >2</span>]
  du[<span class=hljs-number >2</span>] = -p
  du[<span class=hljs-number >3</span>] = u[<span class=hljs-number >4</span>]
  du[<span class=hljs-number >4</span>] = <span class=hljs-number >0.0</span>
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> condition(out,u,t,integrator) <span class=hljs-comment ># Event when event_f(u,t) == 0</span>
  out[<span class=hljs-number >1</span>] = u[<span class=hljs-number >1</span>]
  out[<span class=hljs-number >2</span>] = (u[<span class=hljs-number >3</span>] - <span class=hljs-number >10.0</span>)u[<span class=hljs-number >3</span>]
<span class=hljs-keyword >end</span>

<span class=hljs-keyword >function</span> affect!(integrator, idx)
  <span class=hljs-keyword >if</span> idx == <span class=hljs-number >1</span>
    integrator.u[<span class=hljs-number >2</span>] = -<span class=hljs-number >0.9</span>integrator.u[<span class=hljs-number >2</span>]
  <span class=hljs-keyword >elseif</span> idx == <span class=hljs-number >2</span>
    integrator.u[<span class=hljs-number >4</span>] = -<span class=hljs-number >0.9</span>integrator.u[<span class=hljs-number >4</span>]
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span>

cb = VectorContinuousCallback(condition,affect!,<span class=hljs-number >2</span>)

u0 = [<span class=hljs-number >50.0</span>,<span class=hljs-number >0.0</span>,<span class=hljs-number >0.0</span>,<span class=hljs-number >2.0</span>]
tspan = (<span class=hljs-number >0.0</span>,<span class=hljs-number >15.0</span>)
p = <span class=hljs-number >9.8</span>
prob = ODEProblem(f,u0,tspan,p)
sol = solve(prob,Tsit5(),callback=cb,dt=<span class=hljs-number >1e-3</span>,adaptive=<span class=hljs-literal >false</span>)

plot(sol,vars=(<span class=hljs-number >1</span>,<span class=hljs-number >3</span>))</code></pre> <p><img src="https://user-images.githubusercontent.com/33966400/59046655-0154f280-88a0-11e9-90c5-ea80b501cd27.png" alt="double bounce" /></p> <p>Documentation along with explanation of the code above can be found <a href="https://docs.juliadiffeq.org/latest/features/callback_functions">here</a>.</p> <h2 id=srock ><a href="#srock">SROCK</a></h2> <p>A new class of stiff SDE solvers has been implemented. The SROCK methods are stabilized explicit methods, i.e. no implicit solvers are required. From the literature there are many cases of stiff SDEs where these methods are vastly superior to semi-implicit methods, and thus we are excited to be the first differential equations solver ecosystem to have support for this method. Right now we only have Stratonovich versions of the method, but coming soon are Ito versions and also weak order two versions &#40;SROCK2&#41;. Thanks to Deepesh Shakur &#40;@deeepeshthakur&#41; for this method.</p> <h2 id=improved_nonlinear_solvers_for_stiff_sde_handling ><a href="#improved_nonlinear_solvers_for_stiff_sde_handling">Improved nonlinear solvers for stiff SDE handling</a></h2> <p>The nonlinear solving handling of the SDEs is now in line with the ODEs. Since over the last few months we have had many improvements to the ODE versions, this has been a major update in the stiff SDE handling via semi-implicit methods. Thanks to Kanav Gupta &#40;@kanav99&#41; for this refactoring.</p> <h2 id=multithreaded_extrapolation ><a href="#multithreaded_extrapolation">Multithreaded Extrapolation</a></h2> <p>We now have a new method which exploits multithreading in order to be fast for non-stiff ODEs. This new method, thanks to Saurabh Agarwal &#40;@saurabhkgp21&#41;, multithreads across the <code>f</code> calls of our newest extrapolation methods in order to give a very fast method. Recent papers have shown that this method should benchmark as faster than any non-multithreaded high order RK method. We will be testing this very soon, and it may become one of the main default methods for non-stiff ODEs after Julia&#39;s PARTR &#40;improved multithreading&#41; release.</p> <h2 id=improved_taylorintegration ><a href="#improved_taylorintegration">Improved TaylorIntegration</a></h2> <p>TaylorIntegration.jl will soon be releasing a breaking release that makes its internal interface match that of DifferentialEquations.jl. The result is that its <code>@taylorize</code> macro will now be compatible with common ODE function definitions, making the use of TaylorIntegration.jl from the common interface be about a factor 8 faster. This has shown some superior results when compared to the Feagin 14th order methods, and so we are excited to see whether this becomes the new best method for very high accuracy non-stiff ODE solving. The PR for this is complete and will be merged soon.</p> <h2 id=split-step_milstein_sde_methods ><a href="#split-step_milstein_sde_methods">Split-step Milstein SDE methods</a></h2> <p>Split-step Milstein methods are new strong order 1.0 non-stiff integrators for SDEs. They can be more stable in the presence of high noise. Thanks to Deepesh Shakur &#40;@deeepeshthakur&#41; for this method.</p> <h2 id=no-recompilation_mode_for_odes ><a href="#no-recompilation_mode_for_odes">No-recompilation mode for ODEs</a></h2> <p>We now have the ability to set a no-recompilation mode in ODEs which uses FunctionWrappers.jl to allow one to re-define <code>f</code> without requiring recompilation or re-specailization of the ODE solver code. On non-stiff ODEs this has practically no performance degradation. While this does not allow AD to work through the <code>f</code> function, this is a specific feature which might be useful for certain cases like dynamical systems where many non-stiff ODEs show up and one wants zero recompilation burden. Thanks to Kanav Gupta &#40;@kanav99&#41; for helping complete this feature.</p> <h2 id=next_directions ><a href="#next_directions">Next Directions</a></h2> <p>Some coordination with happening with other parts of the Julia ecosystem to finalize some support. We are discussing/working with the IterativeSolvers.jl developers to make sure GMRES gets fully supported on GPUs: right now there&#39;s a portion with some indexing which isn&#39;t too harmful but triggers errors if <code>CuArrays.allowscalar&#40;false&#41;</code>. In addition, we are working on getting Makie recipes for DifferentialEquations.jl to allow for the auto-plotting to take place on the cool new library &#40;and this will make it easier to handle GPUArrays in plots&#33;&#41;. Integration with Zygote.jl is chugging along, and some tags are needed, but when those go through our DiffEqSensitivity.jl adjoint passes will be able to boast acceleration by Zygote.</p> <p>One of the big things to watch out for in our next release is improvements to sparsity handling, which includes:</p> <ul> <li><p>Surrogate optimization</p> <li><p>Automatic sparsity detection</p> <li><p>Jacobian coloring</p> <li><p>Specialized numerical differentiation and AD on sparse matrices for performance</p> </ul> <p>In addition, the other areas getting some active work are:</p> <ul> <li><p>Better boundary condition handling in DiffEqOperators.jl</p> <li><p>More native implicit ODE &#40;DAE&#41; solvers</p> </ul> <p>With in the background:</p> <ul> <li><p>Adaptivity in the MIRK BVP solvers</p> <li><p>Improved BDF</p> </ul> <div class=page-foot > <div class=copyright > Website powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia</a> programming language. </div> </div> </div>